<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Rocket</title>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
		<link rel="icon" href="favicon.ico" type="image/x-icon"/>
		<link rel="stylesheet" type="text/css" href="style.css" media="screen"/>
	</head>
	<body>
		<pre id="version">v118</pre>
		<p class="hud" id="hudDateOrbit">Loading...</p>
		<p class="hud" id="hudGpsInfo"></p>
		<p class="hud rocketPanel" id="hudFuel">0</p>
		<p class="hud rocketPanel" id="hudThrottle">0%<br>off</p>
		<p class="hud" id="hudStep">1</p>
		<p class="hud" id="hudView">rocket</p>
		<p class="hud rocketPanel" id="hudYaw">0<br>yaw</p>
		<p class="hud rocketPanel" id="hudPitch">0<br>pitch</p>
		<p class="hud rocketPanel" id="hudRoll">0<br>roll</p>

		<script src="threejs/three129.min.js"></script>
		<script src="threejs/TrackballControls129.js"></script>
		<script src="threejs/GLTFLoader129.js"></script>
		<script src="orbMech61.js"></script>
		<script src="tilter14.js"></script>

		<button class="onScreenButton rocketPanel" id="throttleOn" onclick="throttleOn()">throttle on</button>
		<button class="onScreenButton rocketPanel" id="throttleUp" onclick="throttleUp()">throttle up (a)</button>
		<button class="onScreenButton rocketPanel" id="throttleDown" onclick="throttleDown()">throttle down (z)</button>
		<button class="onScreenButton rocketPanel" id="throttleOff" onclick="throttleOff()">throttle off (x)</button>

		<button class="onScreenButton" id="faster" onclick="faster()">double time (t)</button> 
		<button class="onScreenButton" id="slower" onclick="slower()">halve time (g)</button>
		<button class="onScreenButton" id="playPause" onclick="playPause()">pause</button>
		<button class="onScreenButton" id="viewPrevious" onclick="viewPrevious()">previous view</button>
		<button class="onScreenButton" id="viewNext" onclick="viewNext()">next view (v)</button>
		<button class="onScreenButton" id="menuButton" onclick="openPopUpMenu()">menu</button>
		<button class="onScreenButton" id="toggleFullscreen" onclick="toggleFullscreen()">full screen</button>

		<button class="onScreenButton rocketPanel" id="up" onclick="up()">pitch up (e)</button>
		<button class="onScreenButton rocketPanel" id="down" onclick="down()">pitch down (d)</button>
		<button class="onScreenButton rocketPanel" id="left" onclick="left()">yaw left (s)</button>
		<button class="onScreenButton rocketPanel" id="right" onclick="right()">yaw right (f)</button>
		<button class="onScreenButton rocketPanel" id="rollLeft" onclick="rollLeft()">roll left (w)</button>
		<button class="onScreenButton rocketPanel" id="rollRight" onclick="rollRight()">roll right (r)</button>
		<button class="onScreenButton rocketPanel" id="stopSpin" onclick="stopSpin()">stop rotation (q)</button>

		<div class="popup">
			<div class="blocker" onclick="closePopUpMenu()"></div>
			<div class="contents">
				<h3>Stage Separation & Maintenance</h3>
				<button id="stage" class="inMenuButton rocketPanel" onclick="separateStage()">stage</button>
				<button id="fairing" class="inMenuButton rocketPanel" onclick="separateFairing()">fairing</button>
				<button id="refuel" class="inMenuButton rocketPanel" onclick="refuel()">refuel</button>
				<div class="subtext">Refuel available when empty</div>
				<h3>Multiple Rockets</h3>
				<button class="inMenuButton" onclick="addRocket()">deploy</button>
				<button id="recycle" class="inMenuButton rocketPanel" onclick="recycle()">recycle</button>
				<div class="subtext">Recycle available when grounded</div>
				<h3>Heads Up Display</h3>
				<input type="checkbox" id="toggleHud" onchange="toggleHud()">
				<label for="toggleHud">Verbose</label>
				<h3>Visual Helpers</h3>
				<input type="checkbox" id="sprites" onchange="toggleSprites()">
				<label for="sprites">Sprites</label>
				<br>
				<input type="checkbox" id="allOrbits" onchange="toggleAllOrbits()">
				<label for="allOrbits">All Orbits</label>
				<br>
				<input type="checkbox" id="localOrbits" onchange="toggleLocalOrbits()">
				<label for="localOrbits">Local Orbits</label>
				<br>
				<input type="checkbox" id="singleOrbit" onchange="toggleSingleOrbit()">
				<label for="singleOrbit">Always show the orbit for current object</label>
				<br>
				<input type="checkbox" id="localAxes" onchange="toggleAxes()">
				<label for="singleOrbit">Toggle axes for currently viewed object</label>
				<br>
				<input type="checkbox" id="ssbAxes" onchange="toggleSsbAxes()">
				<label for="ssbAxes">Toggle Solar System Barycenter ICRF Axes</label>
				<br>
				<h3>Earth Atmosphere</h3>
				<input type="checkbox" id="clouds" onchange="toggleClouds()">
				<label for="clouds">Show Clouds</label>
				<br>
				<h3>City Lights</h3>
				<div id="cityLightOutput" class="slider"></div>
					<div class="slideContainer">
						<input type="range" min="0" max="100" value="0" class="slider" id="cityLight">
					</div>
				<br>
				<input type="checkbox" id="cityLightLock" onchange="cityLightLock()">
				<label for="cityLightLock">Locked</label>
				<h3>Starlight Intensity (ambient light)</h3>
				<div id="starlightOutput" class="slider"></div>
					<div class="slideContainer">
						<input type="range" min="0" max="100" value="0" class="slider" id="starlight">
					</div>
				<br>
				<input type="checkbox" id="starlightLock" onchange="starlightLock()">
				<label for="starlightLock">Locked</label>
				<h3>Sunlight Intensity (point light)</h3>
				<div id="sunlightOutput" class="slider"></div>
					<div class="slideContainer">
						<input type="range" min="0" max="100" value="0" class="slider" id="sunlight">
					</div>
				<br>
				<input type="checkbox" id="sunlightLock" onchange="sunlightLock()">
				<label for="sunlightLock">Locked</label>
				<h3>Starfield Resolution</h3>
				<input type="radio" id="noStars" value="0" name="stars" onchange="changeStars(value)">
				<label for="noStars">None</label>
				<br>
				<input type="radio" id="1kStars" value="1" name="stars" onchange="changeStars(value)">
				<label for="1kStars">1024 x 1024 x 6, Bright</label>
				<br>
				<input type="radio" id="2kStars" value="2" name="stars" onchange="changeStars(value)">
				<label for="2kStars">2048 x 2048 x 6, Dark</label>
				<br>
				<input type="radio" id="4kStars" value="3" name="stars" onchange="changeStars(value)">
				<label for="4kStars">4096 x 4096 x 6, Dark
					<span id="warn"><em>high memory required</em></span>
				</label>
				<br>
				<h3>Earth Resolution</h3>
				<input type="radio" id="noEarth" value="0" name="earth" onchange="changeEarth(value)">
				<label for="noEarth">None</label>
				<br>
				<input type="radio" id="1kEarth" value="1" name="earth" onchange="changeEarth(value)">
				<label for="1kEarth">1024 x 512</label>
				<br>
				<input type="radio" id="4kEarth" value="2" name="earth" onchange="changeEarth(value)">
				<label for="4kEarth">4096 x 2048, Jpeg Quality 90%</label>
				<br>
				<h3>Reference Plane for objects orbiting the sun</h3>
				<input type="radio" id="eclipticPlane" value="ecliptic" name="plane" onchange="setPlane(value)">
				<label for="eclipticPlane">Ecliptic IAU76/80 & IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="sunBodyPlane" value="body" name="plane" onchange="setPlane(value)">
				<label for="sunBodyPlane">Body - Sun Equator IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="invariablePlane" value="invariable" name="plane" onchange="setPlane(value)">
				<label for="invariablePlane">Invariable Plane IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="galacticPlane" value="galactic" name="plane" onchange="setPlane(value)">
				<label for="galacticPlane">Galactic Plane IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="icrfPlane" value="icrf" name="plane" onchange="setPlane(value)">
				<label for="icrfPlane">ICRF (International Celestial Reference Frame) J2000.0</label>
				<h3>Manage Simulation</h3>
				<button id="reset" class="inMenuButton" onclick="reset()">reset</button>
				<div class="subtext">Reset simulation and preserve settings</div>
				<!--<button id="save" class="inMenuButton" onclick="save()">save</button>
				<div class="subtext">Export simulation</div>-->
				<h3>About</h3>
				<div id="readme">
<pre>
                    _          _
      _ _ ___   __ | | _  ___ | |_
     | ’_/ _ \ / _|| |/ // _ \| __/
     | || (_) | (_ |   <|  __/| |
     |_| \___/ \__||_|\_\\___| \_\
 _ __  _ _ ___   __ _ _ _ __ _ _ __  __
| '_ \| '_/ _ \ / _` | '_/ _` | '_ \’_ \
| (_) | || (_) | (_| | || (_| | | | | | |
| ,__/|_| \___/ \__, |_| \__,_|_| |_| |_|
|_|             |___/
</pre>
<h1 id="this-is-a-rocket-program">this is a rocket program</h1>
<p>this program simulates rocket launches, orbits, and interplanetary spaceflight.</p>
<p><em>the file orbMech.js can be used to convert between Keplerian Orbital Elements and Cartesian State Vectors</em></p>
<h2 id="main-features">main features</h2>
<ul>
<li><p>n-body physics integrated with keplerian physics</p>
<ul>
<li>lagrange points, lissajous orbits, horseshoe orbits, etc.</li>
<li>more accurate and stable than simplectic euler n-body physics</li>
</ul>
</li>
<li><p>oblate spheroids and nodal precession</p>
<ul>
<li>acheive special sun-synchronous orbits, etc.</li>
</ul>
</li>
<li><p>accurate Global Positioning System, altitude, and surface speed</p>
<ul>
<li>track spacecraft in real-scale space, to millimeter precision</li>
</ul>
</li>
<li><p>a navball, affected by both orbital position, and pitch, yaw, and roll</p>
<ul>
<li>a useful tool for monitoring spacecraft orientation</li>
</ul>
</li>
<li><p>US Standard Atmosphere air density model and aerodynamic drag</p>
<ul>
<li>simulate MaxQ (maximum aerodynamic pressure), and orbital decay</li>
</ul>
</li>
<li><p>NASA space object parameters</p>
<ul>
<li>all space objects are placed according to NASA Horizons space data</li>
</ul>
</li>
<li><p>IAU (International Astronomical Union) data for space object axial tilt</p>
<ul>
<li>accurate right ascension, declination, and object rotation in time</li>
</ul>
</li>
</ul>
<h2 id="links">links</h2>
<p><em>development version:</em></p>
<ul>
<li>Live: <a href="https://cubetronic.github.io">https://cubetronic.github.io</a></li>
<li>Code: <a href="https://github.com/cubetronic/cubetronic.github.io">https://github.com/cubetronic/cubetronic.github.io</a></li>
</ul>
<p><em>stable version:</em></p>
<ul>
<li>Live: <a href="https://rocketprogram.github.io">https://rocketprogram.github.io</a></li>
<li>Code: <a href="https://github.com/rocketprogram/rocketprogram.github.io">https://github.com/rocketprogram/rocketprogram.github.io</a></li>
</ul>
<hr>
<ul>
<li><p>many orbital formulas in this program are based on MATLAB scripts from the 2020 textbook <em>Orbital Mechanics for Engineering Students</em> by Curtis. in the practical application of these scripts, necessary adjustments and additions have been made.</p>
</li>
<li><p>this program was developed from scratch, starting with a simple 1-Dimensional concept of a rocket going up. then it became a 2D simulation with a JavaScript canvas. now it&#39;s 3D, with <em>three.js</em> used to render 3D graphics.</p>
</li>
</ul>
<h2 id="user-guide">user guide</h2>
<p><strong>orbital info</strong></p>
<table>
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>period</td>
<td>orbital period, one year is 365.2422 days</td>
</tr>
<tr>
<td>a</td>
<td>semi-major axis</td>
</tr>
<tr>
<td>e</td>
<td>eccentricity</td>
</tr>
<tr>
<td>i</td>
<td>inclination</td>
</tr>
<tr>
<td>Ω</td>
<td>longitude of the ascending node</td>
</tr>
<tr>
<td>ω</td>
<td>argument of periapsis</td>
</tr>
<tr>
<td>M</td>
<td>mean anomaly</td>
</tr>
<tr>
<td>vo</td>
<td>orbital velocity kilometers per second*</td>
</tr>
<tr>
<td>Apo</td>
<td>apoapsis distance from center of mass</td>
</tr>
<tr>
<td>Peri</td>
<td>periapsis distance from center of mass</td>
</tr>
</tbody>
</table>
<p>* the kms listed with orbital info is orbital speed. this is the ECI (earth centered inertial) frame, which means it does NOT consider the spin of the planet/moon/etc.</p>
<p><strong>surface info</strong></p>
<table>
<thead>
<tr>
<th>abbv</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alt</td>
<td>altitude from MSL (mean sea level) at your location</td>
</tr>
<tr>
<td>vs</td>
<td>surface velocity kilometers per second*</td>
</tr>
<tr>
<td>drag</td>
<td>newtons of force</td>
</tr>
<tr>
<td>mass</td>
<td>total mass of object</td>
</tr>
<tr>
<td>Lat</td>
<td>latitude</td>
</tr>
<tr>
<td>Lon</td>
<td>longitude</td>
</tr>
<tr>
<td>Apos</td>
<td>surface apoapsis altitude from MSL at Equator</td>
</tr>
<tr>
<td>Peris</td>
<td>surface periapsis altitude from MSL at Equator</td>
</tr>
</tbody>
</table>
<p>* the kms listed with gps info is surface speed. this is the ECEF (earth-centered earth-fixed) frame, and it DOES consider the spin of the planet/moon/etc.</p>
<p>MSL: Mean Sea Level</p>
<h3 id="reference-plane-for-objects-orbiting-the-sun">Reference Plane for objects orbiting the sun</h3>
<p>this setting allows you to change the data output on the screen for the object you are currently viewing.</p>
<ul>
<li><p>the ecliptic plane is the de facto standard in space literature unless specified.</p>
</li>
<li><p>body equator: this is what the underlying code uses no matter which presentation option is selected, because the program uses it to calculate the J2 zonal harmonic (gravitational effect of the equatorial bulge). this body equator frame, and plane, of reference is the de facto standard for all objects orbiting anything other than the sun, such as moons and satellites.</p>
</li>
<li><p>the invariable plane, not to be confused with la place plane, is a plane which is the sum of all angular momentum of a system, or in other words, the average orbit considering the mass of all planets and objects. (the la place plane is essentially the average plane of an orbit when nodal precession (gravity due to equatorial bulge) and other perturbing forces are taken into account.)</p>
</li>
<li><p>the galactic plane lines up with the milky way.</p>
</li>
<li><p>the ICRF frame is fixed to the stars, and is based on the earth&#39;s equator. this is not usually used in reference to objects orbiting the sun.</p>
</li>
</ul>
<h3 id="axes">Axes</h3>
<p>For Spacecraft:</p>
<ul>
<li>Red points in the Forward +X direction (-X is Aft), the axis of roll.</li>
<li>Blue points Nadir +Z (and -Z is Zenith), the axis of yaw.</li>
<li>Green points Starboard +Y (and -Y is Port), the axis of pitch.</li>
</ul>
<p>For Natural Bodies:</p>
<ul>
<li>shows ICRF axes (long): Blue is +Z and points roughly to the North star (Polaris). Red is +X and points to the Vernal Point (the imaginary line drawn from Earth to the Sun at the moment of the Spring Equinox). Green is +Y and points to 90° Right Ascension. These axes are used for reference. They are fixed to the stars.</li>
<li>and ECEF axes (short): Blue is +Z goes through the positive pole (usually called north, more on that later). Red is +X and goes through the Prime Meridian, and is the center point for most maps. Green is +Y and goes through 90° East.</li>
</ul>
<p>The IAU convention states that the &quot;north&quot; pole of a planet or moon or object is whichever pole is located on the same side of the solar system&#39;s invariable plane as earth&#39;s north pole. This usually means that its north pole is its positive pole, but not for 299, 799, and 999, for example.</p>
<p>However, this program does not follow that convention, because it is arbitrary and breaks other definitions like the definitions of east and west.</p>
<p>Therefore, instead, this program considers a planet, moon, or object&#39;s &quot;north&quot; pole to be its positive pole, which is defined by its rotation. If standing on a planet facing east, the positive pole will be to the left. This is the convention used for exoplanets, and thus is a uniform standard that has no exceptions, and thus is easier to rely upon and use for navigation. It also does not require redefining east and west. For example, in this program, when launching, pointing east will <em>always</em> be an easier orbit to acheive because it will always be a prograde orbit.</p>
<p>Note that which way the sun rises and sets is another matter. Usually, if a planet&#39;s &quot;north&quot; pole is its positive pole, the sun should rise in the east. Yet some planets rotate so slowly that the sunrise and sunset may also be a matter of not just the planet&#39;s own rotation, but also its revolution around the sun. For example, 199 has an other-worldly sunrise sunset pattern.</p>
<h3 id="graphics">Graphics</h3>
<p>In reality, the sun is just pure white. It only appears orange when viewing it with special equipment. Therefore, in this program the sun is pure white, unless specifically viewing it.
The sun does not rotate like planets. Its equator rotates more rapidly than its poles, which is not simulated here, but the general rotation speed is simulated.</p>
<h3 id="navigation-tips">navigation tips</h3>
<ul>
<li><p>if you feel <em>upside down</em>, you can spin the view. tap (or click) and hold and make a circular motion. go clockwise or counter-clockwise to rotate the view. astronauts are always faced with the challenge of determining which way is <em>up</em>. if the ISS (International Space Station) had an axes helper, it would show red forward, roughly east, and blue pointing down towards earth, and green to the right, starboard, which is roughly south because it heads east.</p>
</li>
<li><p>due to current graphics limitations, the visible surface appears to be below the <em>actual</em> surface. so, when a spacecraft is landed on the surface, it will appear to be high up over the surface. trust the gps data, not the graphics.</p>
</li>
<li><p>the faster time is simulated, the more unstable and unreaslistic the simulation is. the timestep is limited to ~8 million times, which is about as fast as it can reliably run for without quickly ejecting the fourth planet&#39;s moons, which is an artificial artifact of warping time, not a realistic feature of space.</p>
</li>
<li><p>to test the <strong>nodal precession</strong> effect, get an orbit that has a low periapsis (i.e. 200km-2000km), then switch to earth view, and crank up the time multiplier. you should notice that the orbit does not stay fixed with respect to the stars. this effect is weaker when orbiting the moon because the moon is not as oblate as earth. The 6th planet is very oblate.</p>
</li>
<li><p>hyperbolic trajectories function accurately, however, helper lines are currently NOT rendered. in previous versions that are not online, code was written to visualize <em>any</em> projected trajectory, even lissajous orbits. unfortunately, that code was very processor-intensive, so i have left it out of this version until i get around to it. therefore, transitioning between orbiting one thing and another thing can be very disorienting. use the nav-ball, orbital elements, and gps info to guide you. good luck! </p>
</li>
</ul>
<h2 id="what-is-simulated">what is simulated</h2>
<ul>
<li><p>it uses n-body physics. this means that every celestial object is having a gravitational effect on every other celestial object. this means that strange orbit types such as lagrangian and horseshoe orbits are possible. even the mass of a spacecraft in this program is calculated to affect the movement of distant planets... yet the numerical precision limits simulating that phenomenon here. still, a spacecraft may have a measurable effect on a very lightweight object nearby.</p>
</li>
<li><p>it <em>also</em> solves the keplerian 2-body problem. it does this between each object and its orbital parent. this increases accuracy dramatically, and also allows for nodal precession. this is probably the trickiest and most unique and innovative aspect of this program. the reasons to implement this are two-fold. firstly, simple n-body physics formulas get very inaccurate the closer objects get to each other. this inaccuracy is avoided by making things that are closest use, instead, the keplerian 2-body formula. simple n-body physics is retained for all other bodies further away. secondly, nodal precession needs to be calculated. this depends on the axial tilt of a body. this is important at close distances, and there are known formulas for calculating nodal precession in conjunction with kepler&#39;s equations.</p>
</li>
<li><p>nodal precession is factored in based on J2 zonal harmonics. this means that the equatorial buldge of each oblate sphereoid (planet, moon, etc.) affects the movement of the orbiting body. nodal precession can be used to acheive the type of sun-sychronous orbit where a satellite is always in direct sunlight, never going into the shade behind the object it is orbiting.</p>
</li>
<li><p>the x-y-z axes colors for the rocket conform to space conventions.</p>
</li>
<li><p>all planets are tilted accurately, not just to the correct amount of tilt, but tilted in the correct direction. IAU data was used. these parameters are known as Right Ascension, Declination, and &quot;W&quot;. &quot;W&quot; is the parameter for the exact rotational position at a specific moment in time. this is used to make sure that the time is correct with respect to day and night on the planet/moon/etc.</p>
</li>
<li><p>real NASA Horizons data is used to create starting points for all objects.</p>
</li>
<li><p>the stars are accurately placed. the images are based on a catalog of all available stars. they are not photos - they are better than photos. different source image brightnesses and resolutions are available in the settings.</p>
</li>
<li><p>everything is at real scale, with real masses. the rocket&#39;s engine thrust has been calibrated to be realistic.</p>
</li>
<li><p>gps coordinates are accurate, even with oblate spheroid bodies.</p>
</li>
<li><p>surface speed is accurate, even with oblate sphereoid bodies.</p>
</li>
<li><p>atmosphere of earth and aerodynamic drag, up to 202,000 km altitude. that&#39;s more than half-way to the moon. so even gps and geostationary satellites experience aerodynamic drag.</p>
</li>
</ul>
<h2 id="what-is-not-simulated">what is not simulated</h2>
<ul>
<li><p>the actual rotation of the spacecraft is more or less lost during and after multiplying the time. this is actually due to the fact that keeping proper rotation over time requires a complex formula that has not yet been built into this simulation. </p>
</li>
<li><p>atmosphere for other planets and moons</p>
</li>
<li><p>the rings of the 6th planet appear unrealistic in a way: they do not receive the shade of the planet, nor do they cast shade. the three.js JavaScript library does not have a good out-of-the-box solution for this. i have experimented with different possible solutions, but they all look worse than just not simulating shade. eclipse shade is also not simulated.</p>
</li>
<li><p>relativity and/or the speed of gravity are not currently simulated. upon developing this simulation, i did some research on special and general relativity. from what i understand, NASA&#39;s Horizons data is unfortunately muddied with counter-corrections for relativity. it&#39;s complicated, and i don&#39;t remember all the details right now, but basically, i believe it may be possible for me to produce an extremely accurate simulation - better than perhaps most simulations, by using a proper implementation of Gerber&#39;s equation regarding the effect of gravity travelling at the speed of light. this should accurately simulate the anomaly of the precession of the first planet. as far as fifth planet flyby anomalies, that is currently an observed phenomenon that puzzles scientists.</p>
</li>
<li><p>tidal forces, such as water and land tidal forces, are not simulated.</p>
</li>
<li><p>solar forces such as electromagnetic storms and heat radiation forces are not simulated.</p>
</li>
<li><p>tidally locked moons do not gyrate properly. they are simply flagged as &#39;tidally locked&#39; in the code, and behave accordingly.</p>
</li>
<li><p>surface terrain such as mountains and valleys are not simulated.</p>
</li>
<li><p>401 gps surface and graphics are different (beyond normal issue of limited segments) due to non-&#39;oblate-spheroid&#39; shape: radiusWest squishes it along another axis, and there is no gps formula here for that. 401 (and 402) are actually better depicted as complicated 3d models anyway.</p>
</li>
</ul>
<h2 id="design-choices">design choices</h2>
<ul>
<li><p>functional programming. wherever possible and practical, <em>pure</em> (independent)  functions are written and utilized. this keeps the working pieces of the program separate, and therefore makes the program more reliable and more extensible. it is my goal to make it so that advanced users and programmers can easily understand and use the code.</p>
</li>
<li><p>the internal structure of the code uses the x, y, and z of space conventions, not cgi graphics animation conventions which is the de facto standard in the threejs 3D library and many other programs. the benefit of using space conventions is that all formulas, source code, data input/output, etc., will not need to be converted. this helps avoid confusion for the advanced users and programmers.</p>
</li>
<li><p>icrf orientation. the x, y, and z used in the program refer to icrf (international celestial reference frame) orientation. this makes it so the threejs built-in skybox can be used for the stars, as it doesn&#39;t have to be rotated. this is the most efficient way to go, and probably makes the most sense.</p>
</li>
<li><p>the surfaces of planets are used as textures instead of with clouds, if i could find surface textures for the object. for example, the 2nd planet surface texture is used. this will aid in attempting to land in the correct location.</p>
</li>
<li><p>hyperbolic trajectories escaping the solar system are caclulated to an extent, and then fail when the transendental equation becomes processor-intensive. in other words, it is limited on purpose. it is possible to remove that limit, or, if travelling away from the sun to great distances is your goal, then i would just switch from an asymptotic trajectory to a linear trajectory or something like that.</p>
</li>
<li><p>this program is designed to allow addition of an unlimited number of celesital objects. the project goal is to include all planets, known moons, dwarf planets, and a good number of asteroids. the program is designed to allow for dynamic transitions where asteroids and moons can be gracefully ejected and become the child of a new planet or celestial object, should the opportunity arise - just like how the rocket can transfer.</p>
</li>
<li><p>the underlying physics engine is called orbMech, which was written so that the code can be used elsewhere. it converts from keplerian orbital elements to cartesian state vectors, and of course also from cartesian state vectors to keplerian orbital elements. if i find the time, perhaps i will make part of this program dedicated to being a conversion calculator.</p>
</li>
<li><p>as a side effect of the way this program was developed, it is possible to bore through planets. this program could also be called &quot;boring program&quot;.</p>
</li>
</ul>

				</div><!-- end readme -->
			</div><!-- end contents -->
		</div><!-- end popup menu -->
		<script src="main.js"></script>
		<script src="bodies.js"></script>
		<script src="runner.js"></script>
	</body>
</html>