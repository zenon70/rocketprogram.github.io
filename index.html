<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Rocket</title>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
		<link rel="icon" href="favicon.ico" type="image/x-icon"/>
		<link rel="stylesheet" type="text/css" href="style.css" media="screen"/>
	</head>
	<body>
		<pre id="version">v78</pre>
		<p class="hud" id="hudDateOrbit">Loading...</p>
		<p class="hud" id="hudGpsInfo"></p>
		<p class="hud rocketPanel" id="hudFuel">0</p>
		<p class="hud rocketPanel" id="hudThrottle">0%<br>off</p>
		<p class="hud" id="hudStep">1</p>
		<p class="hud" id="hudView">rocket</p>
		<p class="hud rocketPanel" id="hudYaw">0<br>yaw</p>
		<p class="hud rocketPanel" id="hudPitch">0<br>pitch</p>
		<p class="hud rocketPanel" id="hudRoll">0<br>roll</p>

		<script src="threejs/three129.min.js"></script>
		<script src="threejs/TrackballControls129.js"></script>
		<script src="threejs/GLTFLoader129.js"></script>
		<script src="orbMech61.js"></script>
		<script src="tilter14.js"></script>

		<button class="onScreenButton rocketPanel" id="throttleOn" onclick="throttleOn()">throttle on</button>
		<button class="onScreenButton rocketPanel" id="throttleUp" onclick="throttleUp()">throttle up (a)</button>
		<button class="onScreenButton rocketPanel" id="throttleDown" onclick="throttleDown()">throttle down (z)</button>
		<button class="onScreenButton rocketPanel" id="throttleOff" onclick="throttleOff()">throttle off (x)</button>

		<button class="onScreenButton" id="faster" onclick="faster()">double time (t)</button> 
		<button class="onScreenButton" id="slower" onclick="slower()">halve time (g)</button>
		<button class="onScreenButton" id="playPause" onclick="playPause()">pause</button>
		<button class="onScreenButton" id="viewPrevious" onclick="viewPrevious()">previous view</button>
		<button class="onScreenButton" id="viewNext" onclick="viewNext()">next view (v)</button>
		<button class="onScreenButton" id="menuButton" onclick="menu()">menu</button>
		<button class="onScreenButton" id="toggleFullscreen" onclick="toggleFullscreen()">full screen</button>

		<button class="onScreenButton rocketPanel" id="up" onclick="up()">pitch up (e)</button>
		<button class="onScreenButton rocketPanel" id="down" onclick="down()">pitch down (d)</button>
		<button class="onScreenButton rocketPanel" id="left" onclick="left()">yaw left (s)</button>
		<button class="onScreenButton rocketPanel" id="right" onclick="right()">yaw right (f)</button>
		<button class="onScreenButton rocketPanel" id="rollLeft" onclick="rollLeft()">roll left (w)</button>
		<button class="onScreenButton rocketPanel" id="rollRight" onclick="rollRight()">roll right (r)</button>
		<button class="onScreenButton rocketPanel" id="stopSpin" onclick="stopSpin()">stop rotation (q)</button>

		<div class="popup">
			<div class="blocker" onclick="hidePopup()"></div>
			<div class="contents">
				<h3>Multiple Rockets</h3>
				<button class="menuButton" onclick="addBody()">add rocket</button>
				<h3>Visual Helpers</h3>
				<input type="checkbox" id="sprites" onchange="toggleSprites()">
				<label for="sprites">Sprites</label>
				<br>
				<input type="checkbox" id="allOrbits" onchange="toggleAllOrbits()">
				<label for="allOrbits">All Orbits</label>
				<br>
				<input type="checkbox" id="localOrbits" onchange="toggleLocalOrbits()">
				<label for="localOrbits">Local Orbits</label>
				<br>
				<button class="menuButton" id="localAxes" onclick="toggleAxes()">Object Axes</button>
				<label for="localAxes">Toggle axes for currently viewed object</label>
				<br>
				<button class="menuButton" id="ssbAxes" onclick="toggleSsbAxes()">SSB Axes</button>
				<label for="ssbAxes">Toggle Solar System Barycenter ICRF Axes</label>
				<br>
				<h3>Starlight Intensity (ambient light)</h3>
				<div id="starlightOutput" class="slider">300%</div>
					<div class="slideContainer">
						<input type="range" min="0" max="100" value="30" class="slider" id="starlight">
					</div>
				<h3>Sunlight Intensity (point light)</h3>
				<div id="sunlightOutput" class="slider">100%</div>
					<div class="slideContainer">
						<input type="range" min="0" max="100" value="100" class="slider" id="sunlight">
					</div>
				<h3>Stars Resolution</h3>
				<input type="radio" id="noStars" value="0" name="stars" onchange="changeStars(value)">
				<label for="noStars">None</label>
				<br>
				<input type="radio" id="1kStars" value="1" name="stars" onchange="changeStars(value)">
				<label for="1kStars">1024 x 1024 x 6, Bright</label>
				<br>
				<input type="radio" id="2kStars" value="2" name="stars" onchange="changeStars(value)">
				<label for="2kStars">2048 x 2048 x 6, Dark</label>
				<br>
				<input type="radio" id="4kStars" value="3" name="stars" onchange="changeStars(value)">
				<label for="4kStars">4096 x 4096 x 6, Dark
					<span id="warn"><em>high memory required</em></span>
				</label>
				<br>
				<h3>Earth Resolution</h3>
				<input type="radio" id="noEarth" value="0" name="earth" onchange="changeEarth(value)">
				<label for="noEarth">None</label>
				<br>
				<input type="radio" id="1kEarth" value="1" name="earth" onchange="changeEarth(value)">
				<label for="1kEarth">1024 x 512</label>
				<br>
				<input type="radio" id="4kEarth" value="2" name="earth" onchange="changeEarth(value)">
				<label for="4kEarth">4096 x 2048, Jpeg Quality 90%</label>
				<br>
				<h3>Reference Plane for objects orbiting the sun</h3>
				<input type="radio" id="eclipticPlane" value="ecliptic" name="plane" onchange="setPlane(value)">
				<label for="eclipticPlane">Ecliptic IAU76/80 & IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="sunBodyPlane" value="body" name="plane" onchange="setPlane(value)">
				<label for="sunBodyPlane">Body - Sun Equator IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="invariablePlane" value="invariable" name="plane" onchange="setPlane(value)">
				<label for="invariablePlane">Invariable Plane IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="galacticPlane" value="galactic" name="plane" onchange="setPlane(value)">
				<label for="galacticPlane">Galactic Plane IAU2009 J2000.0</label>
				<br>
				<input type="radio" id="icrfPlane" value="icrf" name="plane" onchange="setPlane(value)">
				<label for="icrfPlane">ICRF (International Celestial Reference Frame) J2000.0</label>
				<br>
				<h3>About</h3>
				<div id="readme">
<pre>
                    _          _
      _ _ ___   __ | | _  ___ | |_
     | ’_/ _ \ / _|| |/ // _ \| __/
     | || (_) | (_ |   <|  __/| |
     |_| \___/ \__||_|\_\\___| \_\
 _ __  _ _ ___   __ _ _ _ __ _ _ __  __
| '_ \| '_/ _ \ / _` | '_/ _` | '_ \’_ \
| (_) | || (_) | (_| | || (_| | | | | | |
| ,__/|_| \___/ \__, |_| \__,_|_| |_| |_|
|_|             |___/
</pre>
<h1 id="this-is-a-rocket-program">this is a rocket program</h1>
<p>this program simulates rocket launches, orbits, and interplanetary spaceflight.</p>
<p><em>orbMech[ver].js can be used to convert between Keplerian Orbital Elements and Cartesian State Vectors</em></p>
<h2 id="main-features">main features</h2>
<ul>
<li><p>n-body physics integrated with keplerian physics</p>
<ul>
<li>lagrange points, lissajous orbits, horseshoe orbits, etc.</li>
<li>more accurate and stable than simplectic euler n-body physics</li>
</ul>
</li>
<li><p>oblate spheroids and nodal precession</p>
<ul>
<li>acheive special sun-synchronous orbits, etc.</li>
</ul>
</li>
<li><p>accurate Global Positioning System, altitude, and surface speed</p>
<ul>
<li>track spacecraft in real-scale space, to millimeter precision</li>
</ul>
</li>
<li><p>a navball, affected by both orbital position, and pitch, yaw, and roll</p>
<ul>
<li>a useful tool for monitoring spacecraft orientation</li>
</ul>
</li>
<li><p>US Standard Atmosphere air density model and aerodynamic drag</p>
<ul>
<li>simulate MaxQ (maximum aerodynamic pressure), and orbital decay</li>
</ul>
</li>
<li><p>NASA space object parameters</p>
<ul>
<li>all space objects are placed according to NASA Horizons space data</li>
</ul>
</li>
<li><p>IAU (International Astronomical Union) data for space object axial tilt</p>
<ul>
<li>accurate right ascension, declination, and object rotation in time</li>
</ul>
</li>
</ul>
<h2 id="links">links</h2>
<p><em>development version:</em></p>
<ul>
<li>Live: <a href="https://cubetronic.github.io">https://cubetronic.github.io</a></li>
<li>Code: <a href="https://github.com/cubetronic/cubetronic.github.io">https://github.com/cubetronic/cubetronic.github.io</a></li>
</ul>
<p><em>stable version:</em></p>
<ul>
<li>Live: <a href="https://rocketprogram.github.io">https://rocketprogram.github.io</a></li>
<li>Code: <a href="https://github.com/rocketprogram/rocketprogram.github.io">https://github.com/rocketprogram/rocketprogram.github.io</a></li>
</ul>
<hr>
<ul>
<li><p>many orbital formulas in this program are based on MATLAB scripts from the 2020 textbook <em>Orbital Mechanics for Engineering Students</em> by Curtis. in the practical application of these scripts, necessary adjustments and additions have been made.</p>
</li>
<li><p>this program was developed from scratch, starting with a simple 1-Dimensional concept of a rocket going up. then it became a 2D simulation with a JavaScript canvas. now it&#39;s 3D, with <em>three.js</em> used to render 3D graphics.</p>
</li>
</ul>
<h2 id="user-guide">user guide</h2>
<h3 id="key">key</h3>
<p><strong>orbital info</strong></p>
<table>
<thead>
<tr>
<th>symbol</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>semi-major axis</td>
</tr>
<tr>
<td>e</td>
<td>eccentricity</td>
</tr>
<tr>
<td>i</td>
<td>inclination</td>
</tr>
<tr>
<td>Ω</td>
<td>longitude of the ascending node</td>
</tr>
<tr>
<td>ω</td>
<td>argument of periapsis</td>
</tr>
<tr>
<td>M</td>
<td>mean anomaly</td>
</tr>
<tr>
<td>Ap</td>
<td>apoapsis altitude from MSL (mean sea level) at Equator</td>
</tr>
<tr>
<td>Pe</td>
<td>periapsis altitude from MSL (mean sea level) at Equator</td>
</tr>
<tr>
<td>kms</td>
<td>kilometers per second*</td>
</tr>
</tbody>
</table>
<p>* the kms listed with orbital info is orbital speed. this is the ECI (earth centered inertial) frame, which means it does not consider the spin of the planet/moon/etc.</p>
<p><strong>surface info</strong></p>
<table>
<thead>
<tr>
<th>abbv</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lat</td>
<td>latitude</td>
</tr>
<tr>
<td>Lon</td>
<td>longitude</td>
</tr>
<tr>
<td>Alt</td>
<td>altitude from MSL (mean sea level) at your location</td>
</tr>
<tr>
<td>kms</td>
<td>kilometers per second*</td>
</tr>
<tr>
<td>drag</td>
<td>newtons of force</td>
</tr>
</tbody>
</table>
<p>* the kms listed with gps info is surface speed. this is the ECEF (earth-centered earth-fixed) frame, and it does consider the spin of the planet/moon/etc.</p>
<h3 id="reference-plane-for-objects-orbiting-the-sun">Reference Plane for objects orbiting the sun</h3>
<p>this setting allows you to change the data output on the screen for the object you are currently viewing.</p>
<ul>
<li><p>the ecliptic plane is the de facto standard in space literature unless specified.</p>
</li>
<li><p>body equator: this is what the underlying code uses no matter which presentation option is selected, because the program uses it to calculate the J2 zonal harmonic (gravitational effect of the equatorial bulge). this body equator frame, and plane, of reference is the de facto standard for all objects orbiting anything other than the sun, such as moons and satellites.</p>
</li>
<li><p>the invariable plane, not to be confused with la place plane, is a plane which is the sum of all angular momentum of a system, or in other words, the average orbit considering the mass of all planets and objects. (the la place plane is essentially the average plane of an orbit when nodal precession (gravity due to equatorial bulge) and other perturbing forces are taken into account.)</p>
</li>
<li><p>the galactic plane lines up with the milky way.</p>
</li>
<li><p>the ICRF frame is fixed to the stars, and is based on the earth&#39;s equator. this is not usually used in reference to objects orbiting the sun.</p>
</li>
</ul>
<h3 id="navigation-tips">navigation tips</h3>
<ul>
<li><p>if you feel <em>upside down</em>, you can spin the view. tap (or click) and hold and make a circular motion. go clockwise or counter-clockwise to rotate the view. astronauts are always faced with the challenge of determining which way is <em>up</em>. if the ISS (International Space Station) had an axes helper, it would show red forward, roughly east, and blue pointing down towards earth, and green to the right, starboard, which is roughly south because it heads east.</p>
</li>
<li><p>due to current graphics limitations, the visible surface appears to be below the <em>actual</em> surface. so, when a spacecraft is landed on the surface, it will appear to be high up over the surface. trust the gps data, not the graphics.</p>
</li>
<li><p>the faster time is simulated, the more unstable and unreaslistic the simulation is. the timestep is limited to ~8 million times, which is about as fast as it can reliably run for without quickly ejecting the fourth planet&#39;s moons, which is an artificial artifact of warping time, not a realistic feature of space.</p>
</li>
<li><p>to test the <strong>nodal precession</strong> effect, get an orbit that has a low periapsis (i.e. 200km-2000km), then switch to earth view, and crank up the time multiplier. you should notice that the orbit does not stay fixed with respect to the stars. this effect is weaker when orbiting the moon because the moon is not as oblate as earth.</p>
</li>
<li><p>hyperbolic trajectories function accurately, however, helper lines are currently NOT rendered. in previous versions that are not online, code was written to visualize <em>any</em> projected trajectory, even lissajous orbits. unfortunately, that code was very processor-intensive, so i have left it out of this version until i get around to it. therefore, transitioning between orbiting one thing and another thing can be very disorienting. use the nav-ball, orbital elements, and gps info to guide you. good luck! </p>
</li>
</ul>
<h2 id="what-is-simulated">what is simulated</h2>
<ul>
<li><p>it uses n-body physics. this means that every celestial object is having a gravitational effect on every other celestial object. this means that strange orbit types such as lagrangian and horseshoe orbits are possible. even the mass of a spacecraft in this program is calculated to affect the movement of distant planets... yet the numerical precision limits simulating that phenomenon here. still, a spacecraft may have a measurable effect on a very lightweight object nearby.</p>
</li>
<li><p>it <em>also</em> solves the keplerian 2-body problem. it does this between each object and its orbital parent. this increases accuracy dramatically, and also allows for nodal precession. this is probably the trickiest and most unique and innovative aspect of this program. the reasons to implement this are two-fold. firstly, simple n-body physics formulas get very inaccurate the closer objects get to each other. this inaccuracy is avoided by making things that are closest use, instead, the keplerian 2-body formula. simple n-body physics is retained for all other bodies further away. secondly, nodal precession needs to be calculated. this depends on the axial tilt of a body. this is important at close distances, and there are known formulas for calculating nodal precession in conjunction with kepler&#39;s equations.</p>
</li>
<li><p>nodal precession is factored in based on J2 zonal harmonics. this means that the equatorial buldge of each oblate sphereoid (planet, moon, etc.) affects the movement of the orbiting body. nodal precession can be used to acheive the type of sun-sychronous orbit where a satellite is always in direct sunlight, never going into the shade behind the object it is orbiting.</p>
</li>
<li><p>the x-y-z axes colors for the rocket conform to space conventions.</p>
</li>
<li><p>all planets are tilted accurately, not just to the correct amount of tilt, but tilted in the correct direction. IAU data was used. these parameters are known as Right Ascension, Declination, and &quot;W&quot;. &quot;W&quot; is the parameter for the exact rotational position at a specific moment in time. this is used to make sure that the time is correct with respect to day and night on the planet/moon/etc.</p>
</li>
<li><p>real NASA Horizons data is used to create starting points for all objects.</p>
</li>
<li><p>the stars are accurately placed. the images are based on a catalog of all available stars. they are not photos - they are better than photos. different source image brightnesses and resolutions are available in the settings.</p>
</li>
<li><p>everything is at real scale, with real masses. however, the rocket&#39;s engine thrust has not be calibrated to be very realistic yet. it can barely manage a lift-off from earth at 70% throttle, which may even be over-powered still.</p>
</li>
<li><p>gps coordinates are accurate, even with oblate spheroid bodies.</p>
</li>
<li><p>surface speed is accurate, even with oblate sphereoid bodies.</p>
</li>
<li><p>atmosphere of earth and aerodynamic drag, up to 202,000 km altitude. that&#39;s more than half-way to the moon. so even gps satellites experience aerodynamic drag.</p>
</li>
</ul>
<h2 id="what-is-not-simulated">what is not simulated</h2>
<ul>
<li><p>atmosphere for other planets</p>
</li>
<li><p>the rings of the 6th planet appear unrealistic in a way: they do not receive the shade of the planet, nor do they cast shade. the three.js JavaScript library does not have a good out-of-the-box solution for this. i have experimented with different possible solutions, but they all look worse than just not simulating shade. eclipse shade is also not simulated.</p>
</li>
<li><p>relativity and/or the speed of gravity are not currently simulated. upon developing this simulation, i did some research on special and general relativity. from what i understand, NASA&#39;s Horizons data is unfortunately muddied with counter-corrections for relativity. it&#39;s complicated, and i don&#39;t remember all the details right now, but basically, i believe it may be possible for me to produce an extremely accurate simulation - better than perhaps most simulations, by using a proper implementation of Gerber&#39;s equation regarding the effect of gravity travelling at the speed of light. this should accurately simulate the anomaly of the precession of the first planet. as far as fifth planet flyby anomalies, that is currently an observed phenomenon that puzzles scientists.</p>
</li>
<li><p>tidal forces, such as water and land tidal forces, are not simulated.</p>
</li>
<li><p>solar forces such as electromagnetic storms and heat radiation forces are not simulated.</p>
</li>
<li><p>tidally locked moons do not gyrate properly. they are simply flagged as &#39;tidally locked&#39; in the code, and behave accordingly.</p>
</li>
<li><p>surface features such as mountains and valleys are not simulated.</p>
</li>
</ul>
<h2 id="design-choices">design choices</h2>
<ul>
<li><p>functional programming. wherever possible and practical, <em>pure</em> (independent)  functions are written and utilized. this keeps the working pieces of the program separate, and therefore makes the program more reliable and more extensible. it is my goal to make it so that advanced users and programmers can easily understand and use the code.</p>
</li>
<li><p>the internal structure of the code uses the x, y, and z of space conventions, not cgi graphics animation conventions which is the de facto standard in the threejs 3D library and many other programs. the benefit of using space conventions is that all formulas, source code, data input/output, etc., will not need to be converted. this helps avoid confusion for the advanced users and programmers.</p>
</li>
<li><p>icrf orientation. the x, y, and z used in the program refer to icrf (international celestial reference frame) orientation. this makes it so the threejs built-in skybox can be used for the stars, as it doesn&#39;t have to be rotated. this is the most efficient way to go, and, imho, makes the most sense.</p>
</li>
<li><p>the surfaces of planets are used as textures instead of with clouds, if i could find surface textures for the object. for example, the 2nd planet surface texture is used. this will aid in attempting to land in the correct location.</p>
</li>
<li><p>hyperbolic trajectories escaping the solar system are caclulated to an extent, and then fail when the transendental equation becomes processor-intensive. in other words, it is limited on purpose. it is possible to remove that limit, or, if travelling away from the sun to great distances is your goal, then i would just switch from an asymptotic trajectory to a linear trajectory or something like that.</p>
</li>
<li><p>this program is designed to allow addition of an unlimited number of celesital objects. the project goal is to include all planets, known moons, dwarf planets, and a good number of asteroids. the program is designed to allow for dynamic transitions where asteroids and moons can be gracefully ejected and become the child of a new planet or celestial object, should the opportunity arise - just like how the rocket can transfer.</p>
</li>
<li><p>orbMech was written so that the code can be used elsewhere. it simply converts from keplerian orbital elements to cartesian state vectors, and of course also from cartesian state vectors to keplerian orbital elements. if i find the time, perhaps i will make part of this program dedicated to being a conversion calculator.</p>
</li>
<li><p>as a side effect of the way this program was developed, it is possible to bore through planets. this program could also be called &quot;boring program&quot;.</p>
</li>
</ul>
				</div><!-- end readme -->
			</div><!-- end contents -->
		</div><!-- end popup -->
		<script>"use strict";


document.getElementById("starlight").value = 30;
document.getElementById("starlightOutput").innerHTML = "300%";
let starlightControl = 0.3;
let starlightSlider = document.getElementById("starlight");
let starlightOutput = document.getElementById("starlightOutput");
// Update the current slider value (each time you drag the slider handle)
starlightSlider.oninput = function() {
	starlightOutput.innerHTML = this.value * 10 + "%";
	starlightControl = this.value / 100;
	if (body[view].name !== "10") {
		starlight.intensity = starlightControl;
	}
}

document.getElementById("sunlight").value = 100;
document.getElementById("sunlightOutput").innerHTML = "100%";
let sunlightSlider = document.getElementById("sunlight");
let sunlightOutput = document.getElementById("sunlightOutput");
// Update the current slider value (each time you drag the slider handle)
sunlightSlider.oninput = function() {
	sunlightOutput.innerHTML = this.value + "%";
	body[sun].sunlight.intensity = this.value / 100;
}

const popup = document.querySelector('.popup');
function menu() {
	popup.classList.add('open');
}
function hidePopup() {
	popup.classList.remove('open');
}


////////////////////////////////////////////////////////////////////////////////
// n-body initialization

const GRAVITY = 6.6743e-11;
let body = [];
let X, Y, Z, VX, VY, VZ;

// mass in kg, distance in m, sidereal in hours, axial tilt in degrees

// sun ssb kms frame
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB
// these lines begin with a space because that's how they're retrieved from nasa
 X =-1.067598502264559E+06, Y =-3.959890535950128E+05, Z =-1.380711260212289E+05
 VX= 9.312570119052345E-03, VY=-1.170150735349599E-02, VZ=-5.251247980405208E-03

let sun = body.push({
	name: "10",
	focus: null,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 1988500e+24,
	J2: -6.13e-7,
	radiusEquator: 696000000,
	flattening: 0.00005,
	sidereal: 609.12,

	rightAscension: 286.13,
	declination: 63.87,
	primeMeridian: 84.176,

	map: "graphics/sun_1k.jpg",
	color: 0xffffff,
	emissive: 0xffffff
}) - 1;


// 199 sun-centric kms frame
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-1.946172639275932E+07, Y =-5.992796771076561E+07, Z =-2.999277272986019E+07
 VX= 3.699499188030234E+01, VY=-8.529675367206812E+00, VZ=-8.393121028781621E+00

body.push({
	name: "199",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 3.302E+23,
	J2: 50.3e-6,
	radiusEquator: 2439.7e+3,
	flattening: 0,
	sidereal: 1407.5112,

	rightAscension: 281.0097,
	declination: 61.4143,
	primeMeridian: 329.5469,

	//map: "graphics/planet1_2k.jpg",
	color: 0x848383
});

// 299
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-1.074564940489116E+08, Y =-6.922528830161016E+06, Z = 3.686187037221310E+06
 VX= 1.381906047920155E+00, VY=-3.201781843822535E+01, VZ=-1.449183545721332E+01

body.push({
	name: "299",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 48.685e+23,
	J2: 4.458E-6,
	radiusEquator: 6051800,
	flattening: 0,
	sidereal: 5832.443616,

	rightAscension: 92.76,
	declination: -67.16,
	primeMeridian: 160.20 + 180, // iau defines neg as north. adding 180

	//map: "graphics/planet2_2k.jpg",
	color: 0xe4bd7f
});


////////////////////////////////////////////////////////////////////////////////

// earth suncentric kms frame
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-2.649903375682292E+07, Y = 1.327574173547878E+08, Z = 5.755671839918904E+07
 VX=-2.979426006719171E+01, VY=-5.018052326235948E+00, VZ=-2.175393803476646E+00

let earth = body.push({
	name: "399",
	focus: sun,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 5.9723e+24,
	J2: 1.08263e-3,
	radiusEquator: 6378137,
	flattening: 0.0033528106647,
	sidereal: 23.9344695944,

	rightAscension: 0,
	declination: 90,
	primeMeridian: 190.147,

	map: "graphics/planet3_1k.jpg",
	color: 0x419dd9,
	segments: 32
}) - 1;



////////////////////////////////////////////////////////////////////////////////
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X = 2.080481406481886E+08, Y = 2.096192809566167E+05, Z =-5.529162176566044E+06
 VX= 1.162672383641686E+00, VY= 2.391840970779204E+01, VZ= 1.093917189957652E+01

let planet4 = body.push({
	name: "499",
	focus: sun,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 6.4171e+23,
	J2: 1960.45E-6,
	radiusEquator: 3396200,
	flattening: 1/169.779,
	sidereal: 24.622962,

	rightAscension: 317.68143,
	declination: 52.88650,
	primeMeridian: 176.630,

	segments: 48,
	map: "graphics/planet4_2k.jpg",
	color: 0xb76247
}) - 1;


// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X = 5.985676246570733E+08, Y = 4.093863059842168E+08, Z = 1.608943268775537E+08
 VX=-7.909860298437398E+00, VY= 1.018357408916719E+01, VZ= 4.557755398163733E+00
//LT= 2.477748886094049E+03 RG= 7.428104288688971E+08 RR= 2.258267630831523E-01


// 2459001.000000000 = A.D. 2020-May-31 12:00:00.0000 TDB 
//X = 2.437414293329616E+08 Y =-6.727712214984925E+08 Z =-2.943016126910576E+08
//VX= 1.225516283335866E+01 VY= 4.463771559436948E+00 VZ= 1.614962197323810E+00
//LT= 2.580856001046699E+03 RG= 7.737211642978406E+08 RR=-6.349730892716933E-01


body.push({
	name: "599",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 1898.13e+24,
	J2: 14736E-6,
	radiusEquator: 71492000, // [1 bar level]
	flattening: 0.06487,
	sidereal: 0.41353831018518519,

	rightAscension: 268.056595,
	declination: 64.495393,
	primeMeridian: 284.95,

	//map: "graphics/planet5_2k.jpg",
	color: 0xada396
});



// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X = 9.583853590115459E+08, Y = 9.237154716694124E+08, Z = 3.403008584790305E+08
 VX=-7.431212960083195E+00, VY= 6.110152325241220E+00, VZ= 2.842799235017410E+00
//LT= 4.582783973784185E+03 RG= 1.373884071983768E+09 RR=-3.715862595752621E-01


// 2459000.500000000 = A.D. 2020-May-31 00:00:00.0000 TDB 
//X = 6.758845926039357E+08 Y =-1.225678487134377E+09 Z =-5.353728050271363E+08
//VX= 8.098807185095518E+00 VY= 4.134236131926362E+00 VZ= 1.359735455021995E+00
//LT= 4.998713421704984E+03 RG= 1.498576583530528E+09 RR=-2.144372739713913E-01


body.push({
	name: "699",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 5.6834e+26,
	J2: 16298E-6,
	radiusEquator: 60268000, // [1 bar level]
	flattening: 0.09796,
	sidereal: 10.656222222222222,

	rightAscension: 40.589,
	declination: 83.537,
	primeMeridian: 38.90,

	//map: "graphics/planet6_2k.jpg",
	ringsMap: "graphics/planet6rings_1k.png",
	ringsRadius: 140415 * 1000,
	color: 0xcfc0a2
});


// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X = 2.158975041926949E+09, Y =-1.870910936600815E+09, Z =-8.499686292784189E+08
 VX= 4.637273675667743E+00, VY= 4.262810644185866E+00, VZ= 1.801376988633542E+00
//LT= 9.942184157007585E+03 RG= 2.980591826317962E+09 RR= 1.695318155211761E-01

// 2459000.500000000 = A.D. 2020-May-31 00:00:00.0000 TDB 
//X = 2.374742857240990E+09 Y = 1.633720606186591E+09 Z = 6.819437397891679E+08
//VX=-4.108213054984245E+00 VY= 4.693626362353952E+00 VZ= 2.113512723289845E+00
//LT= 9.880196609054756E+03 RG= 2.962008426951790E+09 RR=-2.182906456086245E-01


body.push(
{
	name: "799",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 86.813e+24,
	J2: 3343.43E-6,
	radiusEquator: 25559000, // [1 bar level]
	flattening: 0.02293,
	sidereal: 17.24, // [hours] positive pole is below ICRF equator

	rightAscension: 257.311,
	declination: -15.175,
	primeMeridian: 203.81,

	//map: "graphics/planet7_1k.jpg",
	color: 0x98afb7
});

// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X = 2.515046471488433E+09, Y =-3.437774106196779E+09, Z =-1.469713518152404E+09
 VX= 4.465275187591427E+00, VY= 2.888286548967659E+00, VZ= 1.071024490222010E+00
//LT= 1.503031351116156E+04 RG= 4.505974632021733E+09 RR=-6.058650977577493E-02
/*
// 2459000.500000000 = A.D. 2020-May-31 00:00:00.0000 TDB 
 X = 4.388897213219954E+09, Y =-7.767856116252367E+08, Z =-4.272247742589144E+08
 VX= 1.049326916193281E+00, VY= 4.978334278333246E+00, VZ= 2.011203650372552E+00
//LT= 1.493545505710293E+04 RG= 4.477536782917418E+09 RR=-2.701183494754109E-02
*/

body.push({
	name: "899",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 102.413e+24,
	J2: 3411E-6,
	radiusEquator: 24764000, // [1 bar level]
	flattening: 0.0171,
	sidereal: 16.11,

	rightAscension: 299.36,
	declination: 43.46,
	primeMeridian: 253.18,

	//map: "graphics/planet8_2k.jpg",
	color: 0x364fa7
});

// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-1.477331054174036E+09, Y =-4.185578316848303E+09, Z =-8.607382162350973E+08
 VX= 5.259869708473271E+00, VY=-1.939747281570943E+00, VZ=-2.204071939008186E+00
//LT= 1.508154021829966E+04 RG= 4.521332012469912E+09 RR= 4.966510408247889E-01

// 2459000.500000000 = A.D. 2020-May-31 00:00:00.0000 TDB 
// X = 2.008444000069832E+09 Y =-4.262377536827026E+09 Z =-1.935195748763971E+09
// VX= 5.125280648664118E+00 VY= 1.527076792847321E+00 VZ=-1.082148629054461E+00
//LT= 1.699105308079546E+04 RG= 5.093789567100144E+09 RR= 1.154156585715618E+00


body.push({
	name: "999",
	focus: 0,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 1.307e+22,
	J2: 0.000047386359048791577, // rough est. based on lunar j2/sidereal ratio
	radiusEquator: 1188000,
	flattening: 0,
	sidereal: 153.29335198,

	rightAscension: 132.993,
	declination: -6.163,
	// 0 longitude on the map is the left edge, so add 180
	primeMeridian: 237.305 + 180,

	//map: "graphics/planet9_2k.jpg",
	color: 0x967a63
});



////////////////////////////////////////////////////////////////////////////////

// moon geocentric kms frame
// 2021-01-01 12:00
 X =-2.415972771741238E+05, Y = 2.630988164221789E+05, Z = 1.432200852614276E+05
 VX=-7.683908247177773E-01, VY=-6.430498549296733E-01, VZ=-2.154173653923662E-01

// moon geocentric kms frame
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-2.916083849926414E+05, Y =-2.667168332421485E+05, Z =-7.610248593416973E+04
 VX= 6.435313864033421E-01, VY=-6.660876856217284E-01, VZ=-3.013257041854706E-01

let moon = body.push({
	name: "301",
	focus: earth,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 7.349e+22,
	J2: 202.7E-6,
	radiusEquator: 1738100,
	flattening: 0.0012,
	sidereal: 655.728,
	tidallyLocked: true,

	rightAscension: 269.9949,
	declination: 66.5392,
	primeMeridian: 38.3213,
	
	//map: "graphics/moon301_2k.jpg",
	map: "graphics/moon301_1k.jpg",
	//segments: 64,
	color: 0x969392
}) - 1;

// 401
// mass from https://web.archive.org/web/20131019162634/http://solarsystem.nasa.gov/planets/profile.cfm?Object=Mar_Phobos&Display=Facts

// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-1.989463946057447E+03, Y =-8.743034419032687E+03, Z =-3.181949969502783E+03
 VX= 1.843207370506235E+00, VY=-4.310475264969203E-02, VZ=-1.018331998843603E+00

let moon401 = body.push({
	name: "401",
	focus: planet4,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 10658529896187200,
	radiusEquator: 13.1e3,
	radiusPole: 9.3e3,
	radiusMeridian: 11.1e3,
	sidereal: 0.319 * 24,
	tidallyLocked: true,

	rightAscension: 317.68,
	declination: 52.90,
	primeMeridian: 35.06,

	map: "graphics/moon401_720x360.jpg",
	//segments: 32,
	color: 0x9a8d84
}) - 1;

// 402
// mass from https://web.archive.org/web/20131019172735/http://solarsystem.nasa.gov/planets/profile.cfm?Object=Mar_Deimos&Display=Facts

// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X = 1.036430106515217E+04, Y =-1.574833981312149E+04, Z =-1.394599172365574E+04
 VX= 1.040923986869151E+00, VY= 8.434501190821236E-01, VZ=-1.789391669940932E-01

let moon402 = body.push({
	name: "402",
	focus: planet4,
	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},

	mass: 1476188406600740,
	radiusEquator: 7.8e3,
	radiusPole: 6e3,
	radiusMeridian: 6.0e3,
	sidereal: 1.263 * 24,
	tidallyLocked: true,

	rightAscension: 316.65,
	declination: 53.52,
	primeMeridian: 79.41,

	map: "graphics/moon402_720x360.jpg",
	color: 0xb0aa9f
}) - 1;


// process natural celestial bodies
for (let i = body.length - 1; i > -1; i--) {
	//if (body[i].radiusEquator === undefined) continue;

	if (body[i].J2 === undefined) {
		body[i].J2 = 0;
	}

	body[i].rightAscension *= Math.PI / 180;
	body[i].declination *= Math.PI / 180;
	body[i].primeMeridian *= Math.PI / 180;

	body[i].angularVelocity = 1/(body[i].sidereal * 3600) * 2 * Math.PI;

	if (body[i].flattening === undefined) {
		body[i].flattening = 0;
	}
	body[i].e2 = 2 * body[i].flattening - body[i].flattening**2;

	if (body[i].radiusPole === undefined) {
		body[i].radiusPole = body[i].radiusEquator - (body[i].radiusEquator *
			body[i].flattening);
	}

	body[i].spun = Math.PI / 2 + body[i].primeMeridian;
	
	body[i].type = "Natural";


	if (body[i].segments === undefined) {
		body[i].segments = 16;
	}

/*
	// all this to get Sphere of Influence
	if (i === 0) body[0].radiusSoi = Infinity;
	else {
		let focus = body[i].focus;
		body[i].mu = GRAVITY * (body[focus].mass + body[i].mass);
		body[i].kepler = toKepler(body[i].cartes, body[i].mu);
		// assumes a is positive with e < 1 (not hyperbolic)
		body[i].radiusSoi = body[i].kepler.a *
			(body[i].mass / body[focus].mass)**(2/5);
	}
*/
}






////////////////////////////////////////////////////////////////////////////////
/*
// LRO geocentric kms frame
// 2021-01-01 12:00
 X =-2.428758379542803E+05, Y = 2.624529692028076E+05, Z = 1.420844359324639E+05
 VX=-1.249780236123540E+00, VY=-1.730644095414864E+00, VZ= 9.128278036423180E-01

// iss geocentric kms frame
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-2.090053014379185E+03, Y =-5.522904704730793E+03, Z =-3.284022270901603E+03
 VX= 4.179347954328617E+00, VY=-4.381007125368919E+00, VZ= 4.725905475733050E+00

// Intelsat-901 geocentric kms frame
// 2455198.000000000 = A.D. 2010-Jan-01 12:00:00.0000 TDB 
 X =-5.405605653409561E+03, Y =-4.180316246779086E+04, Z =-2.061177954249511E+00
 VX= 3.050274561890771E+00, VY=-3.943561492961989E-01, VZ=-3.098607080831567E-03

// Voyager 1
// 2451545.000000000 = A.D. 2000-Jan-01 12:00:00.0000 TDB 
 X =-3.046470147980248E+09, Y =-1.071907829729028E+10, Z = 2.375878089046673E+09
 VX=-2.158004379031644E+00, VY=-1.674628408569401E+01, VZ= 3.691435233902702E+00
*/
// intelsat hyperbolic test
 X =-5.405605653409561E+03, Y =-4.180316246779086E+04, Z =-2.061177954249511E+00
 VX= 5.050274561890771E+00, VY=-3.943561492961989E-01, VZ=-3.098607080831567E-03


// test
// 2455198.000000000 = A.D. 2010-Jan-01 12:00:00.0000 TDB 
//X =6378.137, Y =0, Z =0 
//VX=0, VY=1e-5, VZ=0

let rocket = body.push({
	name: "rocket",
	focus: earth,
/*
	mass: 549054,
	fuelMass: 411000,
	burnTime: 559,
*/

	// spaceflightinsider.com/hangar/falcon-9
/*
	// stage 1 only
	mass: 421300,
	fuelMass: 395700,
	burnTime: 162,
*/

	
	// combined stages v1 spacex numbers
	mass: 517870,
	fuelMass: 488370,
	burnTime: 200,
	thrustVac: 8227000,
	thrustSea: 7607000,

	sidereal: null,
	xSpin: 0,
	ySpin: 0,
	zSpin: 0,
	throttleSwitch: false,
	throttle: 0,

	cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
		vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},
	drag: 0,

	pointingV3: new THREE.Vector3(0, 1, 0), // loads y-up
	pointingM4: new THREE.Matrix4(),

	//onSurface: true,
	type: "Artificial",
	color: 0xe5e7e7
}) - 1;


// launch from ground
{
	const i = rocket;
	const focus = body[i].focus;

/*
	// kennedy launch pad 39a
	body[i].gps = {
		lat: 28.60838889 * Math.PI / 180,
		lon: -80.60444444 * Math.PI / 180,
		alt: 0
	};
*/

/*
	// boca chica, texas
	body[i].gps = {
		lat: 25.997354305760496 * Math.PI / 180,
		lon: -97.15698039306052 * Math.PI / 180,
		alt: 0
	};
*/

/*
	// baikonur cosmodrome, kazakhstan
	body[i].gps = {
		lat: 45.92 * Math.PI / 180,
		lon: 63.342 * Math.PI / 180,
		alt: 0  // actually 90 meters, but this program doesn't have terrain yet
	};
*/


	// guiana space center, kourou, french guiana
	body[i].gps = {
		lat: 5.236 * Math.PI / 180,
		lon: -52.775 * Math.PI / 180,
		alt: 0  // actual unknown
	};


	// convert to ecef then to cartes
	body[i].ecef = gpsToEcef(body[i].gps, body[focus].radiusEquator,
		body[focus].e2);
	body[i].cartesEci = ecefToEci(body[i].ecef, body[focus].spun,
		body[focus].angularVelocity, body[focus].radiusEquator, body[focus].e2);

	// save eci for orbital prograde etc
	//body[i].eci = body[i].cartes;

	// not necessary for earth, but should be standard practice
	body[i].cartes = eciToIcrf(body[i].cartesEci,
		body[focus].rightAscension, body[focus].declination);

/*
	// OVERWRITE PREVIOUS... do this instead.. sputnik 1 orbit
	let aTemp = getAxis(947000, 228000, body[focus].radiusEquator);
	let eTemp = getEcc(947000, 228000, body[focus].radiusEquator);
	body[i].kepler = {
		a: aTemp,
		e: eTemp,
		i: 61 * Math.PI / 180,
		lan: 5 * Math.PI / 180,
		w: 5 * Math.PI / 180,
		meanAnom: 5 * Math.PI / 180
	}
	
	let aTemp = getAxis(322000999, 418000999, body[focus].radiusEquator);
	let eTemp = getEcc(322000999, 418000999, body[focus].radiusEquator);
	body[i].kepler = {
		a: aTemp,
		e: eTemp,
		i: 20 * Math.PI / 180,
		lan: 12 * Math.PI / 180,
		w: 61 * Math.PI / 180,
		meanAnom: 146 * Math.PI / 180
	}

	body[i].mu = GRAVITY * (body[focus].mass + body[i].mass);
	body[i].cartesEci = toCartes(body[i].kepler, body[i].mu);
	body[i].ecef = eciToEcef(body[i].cartesEci,
		body[focus].spun,
		body[focus].angularVelocity,
		body[focus].radiusEquator, body[focus].e2);
	body[i].gps = ecefToGps(body[i].ecef, body[focus].radiusEquator,
		body[focus].e2);
	body[i].cartes = eciToIcrf(body[i].cartesEci, body[focus].rightAscension,
		body[focus].declination);
*/

	document.getElementById("hudFuel").innerHTML =
		body[rocket].fuelMass.toFixed(0) + "<br>kg fuel";
}

// add rockets, stage separate, add asteroids, etc.
let bodyQueue = [];
function addBody() {
	let i = bodyQueue.push({
		name: "rocket" + String(body.length + 1 - 13),
		focus: earth,

		// combined stages v1 spacex numbers
		mass: 517870,
		fuelMass: 488370,
		burnTime: 200,
		thrustVac: 8227000,
		thrustSea: 7607000,

		sidereal: null,
		xSpin: 0,
		ySpin: 0,
		zSpin: 0,
		throttleSwitch: false,
		throttle: 0,

		cartes: {x: X * 1000, y: Y * 1000, z: Z * 1000,
			vx: VX * 1000, vy: VY * 1000, vz: VZ * 1000},
		drag: 0,

		pointingV3: new THREE.Vector3(0, 1, 0), // loads y-up
		pointingM4: new THREE.Matrix4(),
	
		//onSurface: true,
		type: "Artificial",
		color: 0xe5e7e7
	}) - 1;
	
	
	// launch from ground
	const focus = bodyQueue[i].focus;

	// boca chica, texas
	bodyQueue[i].gps = {
		lat: 25.997354305760496 * Math.PI / 180,
		lon: -97.15698039306052 * Math.PI / 180,
		alt: 0
	};

	// convert to ecef then to cartes
	bodyQueue[i].ecef = gpsToEcef(bodyQueue[i].gps, body[focus].radiusEquator,
		body[focus].e2);
	bodyQueue[i].cartesEci = ecefToEci(bodyQueue[i].ecef, body[focus].spun,
		body[focus].angularVelocity, body[focus].radiusEquator, body[focus].e2);

	// get kepler (will need to be displayed before next loop)
	bodyQueue[i].mu = GRAVITY * (body[focus].mass + bodyQueue[i].mass);
	bodyQueue[i].kepler = toKepler(bodyQueue[i].cartesEci, bodyQueue[i].mu);

	// not necessary for earth, but should be standard practice
	bodyQueue[i].cartes = eciToIcrf(bodyQueue[i].cartesEci,
		body[focus].rightAscension, body[focus].declination);
/*
	document.getElementById("hudFuel").innerHTML =
		body[i].fuelMass.toFixed(0) + "<br>kg fuel";
*/

}



////////////////////////////////////////////////////////////////////////////////
// prepare for systemPosition()
// assign the most massive body and make it relative to system origin
let mostMassiveBody = 0;
{
	// hard coded to 0.
	/*
	let mostMassiveMass = 0;
	for (let i = body.length - 1; i > -1; i--) {
		if (body[i].mass > mostMassiveMass) {
			mostMassiveMass = body[i].mass;
			mostMassiveBody = i;
		}
	}
	*/
	body[mostMassiveBody].x = body[mostMassiveBody].cartes.x;
	body[mostMassiveBody].y = body[mostMassiveBody].cartes.y;
	body[mostMassiveBody].z = body[mostMassiveBody].cartes.z;
	body[mostMassiveBody].vx = body[mostMassiveBody].cartes.vx;
	body[mostMassiveBody].vy = body[mostMassiveBody].cartes.vy;
	body[mostMassiveBody].vz = body[mostMassiveBody].cartes.vz;
}




////////////////////////////////////////////////////////////////////////////////
// set up three.js

THREE.Object3D.DefaultUp.set(0, 0, 1);

const renderer = new THREE.WebGLRenderer({logarithmicDepthBuffer: true});

let virtualPixel;
if (window.devicePixelRatio) {
	virtualPixel = window.devicePixelRatio;
} else {
	virtualPixel = 1;
}
//renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
renderer.setPixelRatio(virtualPixel);


//renderer.setClearColor("#111111");
renderer.autoClear = false;
//renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const scene2 = new THREE.Scene();

// meters to rendering scale for space scene
let scale = 1e-4;

const camera = new THREE.PerspectiveCamera(
	45,
	window.innerWidth / window.innerHeight,
	0.001,
	1e10
);
//camera.position.set(-200 * scale, 0 * scale, -250 * scale); // texas
//camera.position.set(0 * scale, -300 * scale, 0 * scale); // kazakhstan
camera.position.set(-200 * scale, 0 * scale, -350 * scale); // kourou
camera.up.set(0.62, -0.5, 2); // kourou

const camera2 = new THREE.OrthographicCamera(
	-window.innerWidth / 2,
	window.innerWidth / 2,
	window.innerHeight / 2,
	-window.innerHeight / 2,
	1,
	1000
);

// trackball controls
const controls = new THREE.TrackballControls(camera, renderer.domElement);

// increase damping 4x for snappier controls (default 0.2)
controls.dynamicDampingFactor = 0.8;

controls.rotateSpeed = virtualPixel;

// disable disalignment issue
controls.noPan = true;

controls.update;

	// create solar system barycenter icrf axes helper
	let ssbAxesHelperIcrf = new THREE.AxesHelper(
		body[mostMassiveBody].radiusEquator * 7 * scale);
	// add to scene so it doesn't rotate with parent. must update position.
	scene.add(ssbAxesHelperIcrf);
	ssbAxesHelperIcrf.visible = false;


////////////////////////////////////////////////////////////////////////////////
// gui overlay scene

const ambientLight2 = new THREE.AmbientLight (0xffffff, 0.7);
scene2.add(ambientLight2);

// give navball nice appearance, with bright shine exactly in the center
const pointLight2 = new THREE.PointLight(0xffffff, 0.5);
scene2.add(pointLight2);

let navBall;
{
	// sphere geometry north pole is always +y
	const geometry = new THREE.SphereGeometry(50, 32, 32);
	// the center of image is mapped to +x, with the north pole as +y
	const texture =
		new THREE.TextureLoader().load("graphics/navball_blackgrey.png");
	const material = new THREE.MeshPhongMaterial({ map: texture });
	navBall = new THREE.Mesh(geometry, material);
	scene2.add(navBall);
}

////////////////////////////////////////////////////////////////////////////////
// resize 3d graphics setup as needed

function setResizable() {
	renderer.setSize(window.innerWidth, window.innerHeight);
	pointLight2.position.set(
		(window.innerWidth / 2 ) - 60,
		(window.innerHeight / 2 ) - 60,
		2500
	);
	navBall.position.set(
		(window.innerWidth / 2 ) - 60,
		(window.innerHeight / 2 ) - 60,
		-300
	);
}
setResizable();

window.addEventListener("resize", () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	camera2.left = -window.innerWidth / 2;
	camera2.right = window.innerWidth / 2;
	camera2.top = window.innerHeight / 2;
	camera2.bottom = -window.innerHeight / 2;
	camera2.updateProjectionMatrix();

	setResizable();
});

/* Get the documentElement (<html>) to display the page in fullscreen */
var elem = document.documentElement;

/* View in fullscreen */
function openFullscreen() {
	if (elem.requestFullscreen) {
		elem.requestFullscreen();
	} else if (elem.webkitRequestFullscreen) { /* Safari */
		elem.webkitRequestFullscreen();
	} else if (elem.msRequestFullscreen) { /* IE11 */
		elem.msRequestFullscreen();
	}
}

/* Close fullscreen */
function closeFullscreen() {
	if (document.exitFullscreen) {
		document.exitFullscreen();
	} else if (document.webkitExitFullscreen) { /* Safari */
		document.webkitExitFullscreen();
	} else if (document.msExitFullscreen) { /* IE11 */
		document.msExitFullscreen();
	}
}

let fullscreen = false;
function toggleFullscreen() {
	if (fullscreen === false) {
		openFullscreen();
		fullscreen = true;
	}
	else {
		closeFullscreen();
		fullscreen = false;
	}
}


////////////////////////////////////////////////////////////////////////////////
// space scene

// use for setting tilts, etc
const xAxis = new THREE.Vector3(1, 0, 0);
const yAxis = new THREE.Vector3(0, 1, 0);
const zAxis = new THREE.Vector3(0, 0, 1);

/*
// scene axes at origin
const axesHelper = new THREE.AxesHelper(25e9 * scale);
scene.add(axesHelper);
*/

document.getElementById("1kStars").checked = true;
function changeStars(value) {
	if (scene.background) {
		scene.background.dispose();
	}
	switch (value) {
		case "0":
			scene.background = null;
			break;
		case "1":
			// 1k (1024x1024) Low Resolution (from bright 8k TIFF)
			// skybox: icrf breakout with rotations
			scene.background = new THREE.CubeTextureLoader().load([
				"graphics/stars_1kBright/1k-nzLeft.jpg",
				"graphics/stars_1kBright/1k-pzRight.jpg",
				"graphics/stars_1kBright/1k-nx180.jpg",
				"graphics/stars_1kBright/1k-px.jpg",
				"graphics/stars_1kBright/1k-pyRight.jpg",
				"graphics/stars_1kBright/1k-nyRight.jpg"
				]);

			// pixelated and more efficient
			scene.background.magFilter = THREE.NearestFilter;
			scene.background.minFilter = THREE.NearestFilter;

			scene.background.needsUpdate = true;
			break;
		case "2":
			// 2k Medium Resolution (from dark 16k TIFF)
			// skybox: icrf breakout with rotations
			scene.background = new THREE.CubeTextureLoader().load([
				"graphics/stars_2kDark/2k-nzLeft.jpg",
				"graphics/stars_2kDark/2k-pzRight.jpg",
				"graphics/stars_2kDark/2k-nx180.jpg",
				"graphics/stars_2kDark/2k-px.jpg",
				"graphics/stars_2kDark/2k-pyRight.jpg",
				"graphics/stars_2kDark/2k-nyRight.jpg"
				]);

			// pixelated and more efficient
			scene.background.magFilter = THREE.NearestFilter;
			scene.background.minFilter = THREE.NearestFilter;

			scene.background.needsUpdate = true;
			break;
		case "3":
			// TOO LARGE. CRASHES BROWSER ON SMARTPHONE WITH 2GB MEMORY
			// 4k High Resolution (from dark 16k TIFF)
			// skybox: icrf breakout with rotations
			scene.background = new THREE.CubeTextureLoader().load([
				"graphics/stars_4kDark/4k-nzLeft.jpg",
				"graphics/stars_4kDark/4k-pzRight.jpg",
				"graphics/stars_4kDark/4k-nx180.jpg",
				"graphics/stars_4kDark/4k-px.jpg",
				"graphics/stars_4kDark/4k-pyRight.jpg",
				"graphics/stars_4kDark/4k-nyRight.jpg"
				]);

			// pixelated and more efficient
			scene.background.magFilter = THREE.NearestFilter;
			scene.background.minFilter = THREE.NearestFilter;

			scene.background.needsUpdate = true;
			break;
		default:
			scene.background = null;
	} 
}
changeStars("1");

document.getElementById("1kEarth").checked = true;
function changeEarth(value) {
	if (body[earth].mesh.material.map) {
		body[earth].mesh.material.map.dispose();
		body[earth].mesh.material.map = null;
	}
	switch (value) {
		case "0":
			body[earth].map = null;
			//body[earth].mesh.material.map = null;
			if (body[earth].color) {
				body[earth].mesh.material.color.setHex(body[earth].color);
			}
			body[earth].mesh.material.needsUpdate = true;
			break;
		case "1":
			body[earth].mesh.material.color.setHex(0xffffff);
			body[earth].map = "graphics/planet3_1k.jpg";
			body[earth].mesh.material.map =
				new THREE.TextureLoader().load(body[earth].map);

			// pixelated and more efficient
			body[earth].mesh.material.map.magFilter = THREE.NearestFilter;
			body[earth].mesh.material.map.minFilter = THREE.NearestFilter;

			body[earth].mesh.material.needsUpdate = true;
			break;
		case "2":
			body[earth].mesh.material.color.setHex(0xffffff);
			body[earth].map = "graphics/planet3_4k.jpg";
			body[earth].mesh.material.map =
				new THREE.TextureLoader().load(body[earth].map);

			// pixelated and more efficient
			body[earth].mesh.material.map.magFilter = THREE.NearestFilter;
			body[earth].mesh.material.map.minFilter = THREE.NearestFilter;

			body[earth].mesh.material.needsUpdate = true;
			break;
		default:
			body[earth].map = null;
			body[earth].mesh.material.map = null;
			if (body[earth].color) {
				body[earth].mesh.material.color.setHex(body[earth].color);
			}
			body[earth].mesh.material.needsUpdate = true;
	} 
}




// ambient light (stars, etc)
const starlight = new THREE.AmbientLight (0xffffff);
scene.add(starlight);



// planets, moons, etc: oblate spheroids (with helpers)
for (let i = body.length - 1; i > -1; i--) {
	if (body[i].type === "Artificial") continue;

	let material;

	if (body[i].map !== undefined && body[i].map !== null) {
		material = new THREE.MeshLambertMaterial({
			map: new THREE.TextureLoader().load(body[i].map)});

		material.map.magFilter = THREE.NearestFilter;
		material.map.minFilter = THREE.NearestFilter;

	} else if (body[i].color !== undefined) {
			material = new THREE.MeshLambertMaterial({
				color: body[i].color});
	} else {
		material = new THREE.MeshLambertMaterial();
	}

	body[i].mesh = new THREE.Mesh(new THREE.SphereGeometry(
		body[i].radiusEquator * scale, body[i].segments, body[i].segments / 2),
		material);

	// shadows
	//body[i].mesh.castShadow = true;
	//body[i].mesh.receiveShadow = true;


	if (body[i].emissive !== undefined) {
		body[i].mesh.material.emissive.set(body[i].emissive);
	}

	//body[i].mesh.material.transparent = true;
	//body[i].mesh.material.opacity = 0.8;

	body[i].mesh.scale.y = body[i].radiusPole / body[i].radiusEquator;
	if (body[i].radiusMeridian !== undefined) {
		body[i].mesh.scale.z = body[i].radiusPole / body[i].radiusEquator;
	}


	// rings
	if (body[i].ringsRadius !== undefined && body[i].ringsMap !== undefined) {
		body[i].rings = new THREE.Mesh(
			new THREE.PlaneGeometry(
				body[i].ringsRadius * 2 * scale, body[i].ringsRadius * 2 * scale),
			new THREE.MeshBasicMaterial({
				map: new THREE.TextureLoader().load(body[i].ringsMap),
				transparent: true,
				side: THREE.DoubleSide})
			);
		body[i].rings.rotation.set(Math.PI / 2, 0, 0);
		//body[i].rings.castShadow = true;
		//body[i].rings.receiveShadow = true;
		body[i].mesh.attach(body[i].rings);
	}

	// turn to z-up, then Dec, thrn RA, then W.
	body[i].mesh.rotation.set(Math.PI / 2, 0, -Math.PI / 2 + body[i].declination);
	body[i].mesh.rotateOnWorldAxis(zAxis, body[i].rightAscension);
	body[i].mesh.rotateY(Math.PI / 2 + body[i].primeMeridian);

	scene.add(body[i].mesh);

	// create ecef axes helper
	body[i].axesHelper = new THREE.AxesHelper(body[i].radiusEquator * 1.5 *
		scale);
	// same config as spheroid
	body[i].axesHelper.rotation.set(Math.PI / 2, 0, -Math.PI / 2 +
		body[i].declination);
	body[i].axesHelper.rotateOnWorldAxis(zAxis, body[i].rightAscension);
	body[i].axesHelper.rotateY(Math.PI / 2 + body[i].primeMeridian);
	// rotate to appear as z-up (space axes convention)
	body[i].axesHelper.rotateX(-Math.PI / 2);
	body[i].mesh.attach(body[i].axesHelper);
	body[i].axesHelper.visible = false;

	// create icrf axes helper
	body[i].axesHelperIcrf = new THREE.AxesHelper(
		body[i].radiusEquator * 3 * scale);
	// add to scene so it doesn't rotate with parent. must update position.
	scene.add(body[i].axesHelperIcrf);
	body[i].axesHelperIcrf.visible = false;



	{
		const map = new THREE.TextureLoader().load("graphics/circle-64.png");
		body[i].sprite = new THREE.Sprite(new THREE.SpriteMaterial({
			map: map,
			color: body[i].color,
			sizeAttenuation: false}));
		body[i].sprite.scale.set(100 * scale, 100 * scale, 1)
		body[i].mesh.add(body[i].sprite);
	}
}



// disable sun shadow
//body[sun].mesh.castShadow = false;
//body[sun].mesh.receiveShadow = false;


// sunlight
body[sun].sunlight = new THREE.PointLight(0xffffff, 1);
//body[sun].sunlight.castShadow = true;

//Set up shadow properties for the light
//body[sun].sunlight.shadow.mapSize.width = 512; // default
//body[sun].sunlight.shadow.mapSize.height = 512; // default
//body[sun].sunlight.shadow.camera.near = body[sun].radiusPole - 10000 * scale;
//body[sun].sunlight.shadow.camera.far = 7500e9 * scale;

body[sun].mesh.add(body[sun].sunlight);



//Create a helper for the shadow camera (optional)
//const shadowHelper = new THREE.CameraHelper(body[sun].sunlight.shadow.camera);
//scene.add(shadowHelper);









let view;

// rocket
function addRocket(i) {

	// stage 1
	const geometry = new THREE.CylinderGeometry(
		1.83 * scale, 1.83 * scale, 42.6 * scale, 16);
	const texture = new THREE.TextureLoader().load("graphics/f9stage1.png");
	texture.magFilter = THREE.NearestFilter;
	texture.minFilter = THREE.NearestFilter;
	const material = new THREE.MeshLambertMaterial({
		map: texture
		});
	body[i].mesh = new THREE.Mesh(geometry, material);

	// bottom cap to hide stage 1 graphics wrap
	body[i].cap = new THREE.Mesh(new THREE.CylinderGeometry(
		1.83 * scale, 1.83 * scale, 0.02 * scale, 16),
		new THREE.MeshLambertMaterial({color:0x333333}));
	body[i].cap.position.set(0, -21.31 * scale, 0);
	body[i].mesh.add(body[i].cap);

	// stage 2
	const geometry2 = new THREE.CylinderGeometry(
		1.83 * scale, 1.83 * scale, 13.8 * scale, 16);
	const material2 = new THREE.MeshLambertMaterial();
	body[i].stage2 = new THREE.Mesh(geometry2, material2);
	body[i].stage2.position.set(0, 27.6 * scale, 0);
	body[i].mesh.add(body[i].stage2);

	// fairing base expansion section
	body[i].fairingBase = new THREE.Mesh(new THREE.CylinderGeometry(
		2.6 * scale, 1.83 * scale, 1.3 * scale, 16),
		new THREE.MeshLambertMaterial());
	body[i].fairingBase.position.set(0, 34.55 * scale, 0);
	body[i].mesh.add(body[i].fairingBase);

	// fairing mid section
	body[i].fairingMid = new THREE.Mesh(new THREE.CylinderGeometry(
		2.6 * scale, 2.6 * scale, 6.7 * scale, 16),
		new THREE.MeshLambertMaterial());
	body[i].fairingMid.position.set(0, 38.55 * scale, 0);
	body[i].mesh.add(body[i].fairingMid);

	// fairing nose aerodynamic shape
	body[i].fairingNose = new THREE.Mesh(new THREE.SphereGeometry(
		2.6 * scale, 16, 8, 0, 2 * Math.PI, 0, Math.PI / 2),
		new THREE.MeshLambertMaterial());
	body[i].fairingNose.position.set(0, 41.9 * scale, 0);
	//body[i].fairingNose.rotation.set(0, Math.PI / 2, 0); // for texture
	body[i].fairingNose.scale.y = 2;
	body[i].mesh.add(body[i].fairingNose);


		//body[i].mesh.receiveShadow = true;

		body[i].mesh.up.set(0, 1, 0);

		// rotate mesh so it's standing up on the ground:
		// get the direction vector that defines up relative to ground...
		// the cheap and easy way is for a sphere, not oblate spheroid
		// and this way also aligns with the navball
		const focus = body[i].focus;
		let enu = getDirections(body[i].cartes.x, body[i].cartes.y, body[i].cartes.z,
			body[focus].mesh.quaternion);
		let navM4 = new THREE.Matrix4().makeBasis(
			enu.northAxisV3, enu.upAxisV3, enu.eastAxisV3);
		body[i].mesh.quaternion.setFromRotationMatrix(navM4);

		// set so pitching down points east
		body[i].mesh.rotateY(Math.PI);

		// update thrust vector
		body[i].pointingV3.set(body[i].cartes.x, body[i].cartes.y, body[i].cartes.z)
			.normalize();

		scene.add(body[i].mesh);


		body[i].axesHelper = new THREE.AxesHelper(250e3 * scale);
		body[i].axesHelper.rotation.copy(body[i].mesh.rotation);
		// rotate to NED (north, east, down) convention for spacecraft
		// +x forward, -x aft
		// +y starboard, -y port
		// +z nadir, -z zenith
		body[i].axesHelper.rotateX(Math.PI);
		body[i].axesHelper.rotateZ(-Math.PI / 2);
		body[i].mesh.attach(body[i].axesHelper);
		body[i].axesHelper.visible = false;

		body[i].thrustArrow = new THREE.ArrowHelper(
			body[i].pointingV3,
			body[i].mesh.position,
			1000e3 * scale,
			0xff0000);
		body[i].mesh.attach(body[i].thrustArrow);
		body[i].thrustArrow.visible = false;


		body[i].sprite = new THREE.Sprite(new THREE.SpriteMaterial({
			map: new THREE.TextureLoader().load("graphics/triangle-64.png"),
			color: body[i].color,
			sizeAttenuation: false}));

		// scale sprite for gltf model mk1r2
		//body[i].sprite.scale.set(1000, 1000, 1)
		// scale sprite for cylinder geometry
		body[i].sprite.scale.set(0.01, 0.01, 1);

		body[i].mesh.add(body[i].sprite);


		// post-setup global adjustments
		view = i;
		viewFinalize();
		controls.target = body[view].mesh.position;
		controls.minDistance = 75 * scale;

	// brackets for gltf
	//});
}
addRocket(rocket);

document.querySelector("#sprites").checked = true;
function toggleSprites() {
	if (body[0].sprite.visible === true) {
		for (let i = body.length - 1; i > -1; i--) {
			body[i].sprite.visible = false;
		}
	} else {
		for (let i = body.length - 1; i > -1; i--) {
			body[i].sprite.visible = true;
		}
	}
}

//document.querySelector("#axes").checked = false;
function toggleAxes() {
	if (body[view].type === "Artificial") {
		if (body[view].axesHelper.visible === true) {
			body[view].axesHelper.visible = false;
			body[view].thrustArrow.visible = false;
		} else {
			body[view].axesHelper.visible = true;
			body[view].thrustArrow.visible = true;
		}
	} else {
		if (body[view].axesHelper.visible === true) {
			body[view].axesHelper.visible = false;
			body[view].axesHelperIcrf.visible = false;
		} else {
			body[view].axesHelper.visible = true;
			body[view].axesHelperIcrf.visible = true;
		}
	}
}

function toggleSsbAxes() {
	if (ssbAxesHelperIcrf.visible) {
		ssbAxesHelperIcrf.visible = false;
	} else {
		ssbAxesHelperIcrf.visible = true;
	}
}

////////////////////////////////////////////////////////////////////////////////
// get system positions
// using icrf-oriented vectors for each body relative to its parent,
// find its solar system barycenter vectors
/*
	requires:
		mostMassiveBody
		scale
		body [array]
			.cartes [icrf]
			.mesh.position [threejs vector3]
			.focus [integer]

	returns:
		.x positions
		.mesh.position.x positions
*/


function systemPosition() {
	// skip sun. order is important. increment to move focii before satellites
	for (let i = 1; i < body.length; i++) {

		// start with the current focus
		let focus = body[i].focus;

		// start with local coordinates 
		body[i].x = body[i].cartes.x;
		body[i].y = body[i].cartes.y;
		body[i].z = body[i].cartes.z;
		body[i].vx = body[i].cartes.vx;
		body[i].vy = body[i].cartes.vy;
		body[i].vz = body[i].cartes.vz;

		// recurse through foci (parents), adding values along the way
		let recurse = true;
		while (recurse) {
			// when the most massive body (i.e. sun) is reached, add that and exit
			if (focus === mostMassiveBody) {
				body[i].x += body[focus].x;
				body[i].y += body[focus].y;
				body[i].z += body[focus].z;
				body[i].vx += body[focus].vx;
				body[i].vy += body[focus].vy;
				body[i].vz += body[focus].vz;
				recurse = false;
			}
			else {
				// add cartesian values of the parent AKA focus body
				body[i].x += body[focus].cartes.x;
				body[i].y += body[focus].cartes.y;
				body[i].z += body[focus].cartes.z;
				body[i].vx += body[focus].cartes.vx;
				body[i].vy += body[focus].cartes.vy;
				body[i].vz += body[focus].cartes.vz;

				// traverse up one level to its parent
				focus = body[focus].focus;
			}
		}

		// apply the system coordinates for rendering
		body[i].mesh.position.x = body[i].x * scale;
		body[i].mesh.position.y = body[i].y * scale;
		body[i].mesh.position.z = body[i].z * scale;
	}
}
// initialize positions
body[mostMassiveBody].mesh.position.x = body[mostMassiveBody].x * scale;
body[mostMassiveBody].mesh.position.y = body[mostMassiveBody].y * scale;
body[mostMassiveBody].mesh.position.z = body[mostMassiveBody].z * scale;
systemPosition();



////////////////////////////////////////////////////////////////////////////////
// view control
view = rocket;

// dynamic and intuitive view order, by periapsis
// periapsis chosen due to higher drag of satellites with low periapsis.
// 999 seems to appear out of order due to sort by periapsis
// to "fix", change it to measure by semi-major axis.

function viewNext() {

	let next = null;
	let highPeri = Infinity;
	let localView = view;

	let lowPeri = 0; // in case view is sun
	let localFocus = mostMassiveBody; // in case view is sun
	if (localView !== mostMassiveBody) {
		lowPeri = body[localView].kepler.periapsis;
		localFocus = body[localView].focus;
	}

	let child = null;
	let lowOrbit = Infinity;

	let ignoreChildren = false;


	function getHigher() {
		for (let i = body.length - 1; i > 0; i--) { // skip sun
			// catch things orbiting what is being viewed
			if (body[i].focus === localView && body[i].kepler.periapsis < lowOrbit &&
				ignoreChildren === false) {
				child = i;
				lowOrbit = body[i].kepler.periapsis;
				next = null;
			}
			// check for things further out
			else if (child === null && body[i].focus === localFocus &&
				body[i].kepler.periapsis > lowPeri &&
				body[i].kepler.periapsis < highPeri) {
				highPeri = body[i].kepler.periapsis;
				next = i;
			}
		}
	}
	getHigher(localFocus);

	while (next === null) {
		if (child !== null) {
			// it is the lowest peri, but does it have children? reset and rerun
			localFocus = localView;
			localView = child;
			highPeri = Infinity;
			lowPeri = 0;
			child = null;
			lowOrbit = Infinity;
			getHigher();
		}
		// nothing is further out in this gravity area, so go to its parent system
		else if (localFocus !== mostMassiveBody) {
			localView = localFocus;
			lowPeri = body[localView].kepler.periapsis;
			localFocus = body[localFocus].focus;
			ignoreChildren = true;
			getHigher();
		} else {
			next = mostMassiveBody;
		}
	}

	view = next;
	viewFinalize();
}


function viewPrevious() {

	let potentialResult = null;
	let tooLow = 0;
	let tooHigh = Infinity; // in case view is sun
	let focusNow = mostMassiveBody; // in case view is sun
	if (view !== mostMassiveBody) {
		tooHigh = body[view].kepler.periapsis;
		focusNow = body[view].focus;
	}

	function getLower() {
		for (let i = body.length - 1; i > 0; i--) { // skip sun
			if (body[i].focus === focusNow &&
				body[i].kepler.periapsis < tooHigh &&
				body[i].kepler.periapsis > tooLow) {
				potentialResult = i;
				tooLow = body[i].kepler.periapsis;
			}
		}
	}
	getLower();

	while (potentialResult !== null) {
		focusNow = potentialResult;
		potentialResult = null;
		tooLow = 0;
		tooHigh = Infinity;
		getLower();
	}
	
	view = focusNow;
	viewFinalize();
}


function viewFinalize() {

	controls.target = body[view].mesh.position;

	if (body[view].type === "Natural") {
		controls.minDistance = body[view].radiusEquator * 1.2 * scale;
	}
	else {
		controls.minDistance = 60 * scale;
	}

	// sun view
	if (view === 0) {
		body[view].mesh.material.emissiveIntensity = 0;
		starlight.intensity = 1;
		document.getElementById("hudView").innerHTML = body[view].name + "<br>@ " +
			"mlky";
	}
	else {
		body[mostMassiveBody].mesh.material.emissiveIntensity = 1;
		starlight.intensity = starlightControl;
		document.getElementById("hudView").innerHTML = body[view].name + "<br>@ " +
			body[body[view].focus].name;
	}

	if (body[view].type === "Artificial") {
		scene2.visible = true;
		document.getElementById("hudFuel").innerHTML =
			body[view].fuelMass.toFixed(0) + "<br>kg fuel";
		document.getElementById("hudPitch").innerHTML =
			Math.round(body[view].xSpin * 10) + "<br>pitch";
		document.getElementById("hudYaw").innerHTML =
			Math.round(- body[view].ySpin * 10) + "<br>yaw";
		document.getElementById("hudRoll").innerHTML =
			Math.round(body[view].zSpin * 10) + "<br>roll";

		let panel = document.getElementsByClassName("rocketPanel");
		for (let i = panel.length - 1; i > -1; i--) {
			panel[i].style.visibility = "visible";
		}
		
	} else {
		scene2.visible = false;
		let panel = document.getElementsByClassName("rocketPanel");
		for (let i = panel.length - 1; i > -1; i--) {
			panel[i].style.visibility = "hidden";
		}/*
		document.getElementById("hudFuel").innerHTML = "";
		document.getElementById("hudPitch").innerHTML = "";
		document.getElementById("hudYaw").innerHTML = "";
		document.getElementById("hudRoll").innerHTML = "";
		*/
	}

	throttleShow();

	//body[view].mesh.attach(camera);
}
viewFinalize();



////////////////////////////////////////////////////////////////////////////////
// time

// max loop speed is 100x per second. slower depending on load and cpu speed
// 8 million times is relatively stable, though wobbly
// 16 million times will eject moons 401 and 402 in about a minute
let timestep = 0.01;
function faster() {
	if (timestep < 80000) timestep *= 2;
	document.getElementById("hudStep").innerHTML = Math.round(timestep * 100);
}
function slower() {
	if (timestep > .01) timestep /= 2;
	if (timestep < .01) timestep = .01;
	document.getElementById("hudStep").innerHTML = Math.round(timestep * 100);
}

// start with J2000.0 date to match positions and rotations
let now = new Date(Date.UTC(2000, 0, 1, 12, 0, 0));

////////////////////////////////////////////////////////////////////////////////
// rocket control (spin and thrust)
/*
let xSpin = 0;
let ySpin = 0;
let zSpin = 0;
*/
let spinPower = 0.1; // what units? m/s²

// onscreen buttons
function up() {
	if (body[view].type === "Artificial") {
		body[view].xSpin += spinPower;
	}
	document.getElementById("hudPitch").innerHTML =
		Math.round(body[view].xSpin * 10) + "<br>pitch";
}
function down() {
	if (body[view].type === "Artificial") {
		body[view].xSpin -= spinPower;
	}
	document.getElementById("hudPitch").innerHTML =
		Math.round(body[view].xSpin * 10) + "<br>pitch";
}
function left() {
	if (body[view].type === "Artificial") {
		body[view].zSpin += spinPower;
	}
	document.getElementById("hudYaw").innerHTML =
		Math.round(- body[view].zSpin * 10) + "<br>yaw";
}
function right() {
	if (body[view].type === "Artificial") {
		body[view].zSpin -= spinPower;
	}
	document.getElementById("hudYaw").innerHTML =
		Math.round(- body[view].zSpin * 10) + "<br>yaw";
}
function rollLeft() {
	if (body[view].type === "Artificial") {
		body[view].ySpin -= spinPower;
	}
	document.getElementById("hudRoll").innerHTML =
		Math.round(body[view].ySpin * 10) + "<br>roll";
}
function rollRight() {
	if (body[view].type === "Artificial") {
		body[view].ySpin += spinPower;
	}
	document.getElementById("hudRoll").innerHTML =
		Math.round(body[view].ySpin * 10) + "<br>roll";
}
function stopSpin() {
	if (body[view].type === "Artificial") {
		body[view].xSpin = 0;
		body[view].ySpin = 0;
		body[view].zSpin = 0;
	}
	document.getElementById("hudPitch").innerHTML =
		Math.round(body[view].xSpin * 10) + "<br>pitch";
	document.getElementById("hudYaw").innerHTML =
		Math.round(- body[view].zSpin * 10) + "<br>yaw";
	document.getElementById("hudRoll").innerHTML =
		Math.round(body[view].ySpin * 10) + "<br>roll";
}


// here

/*
let throttleSwitch = false;
let throttle = 0; // 0 to 100
*/
function throttleShow() {
	if (body[view].throttleSwitch) {
		document.getElementById("hudThrottle").innerHTML = body[view].throttle
			+ "%<br>on";
	// make sure it's false, not undefined as if a "Natural" body
	} else if (body[view].throttleSwitch === false) {
		document.getElementById("hudThrottle").innerHTML = body[view].throttle
			+ "%<br>off";
	} else {
		document.getElementById("hudThrottle").innerHTML = "";
		
	}
}
function throttleOn() {
	if (body[view].type === "Artificial") {
		body[view].throttleSwitch = true;
		throttleShow();
	}
}
function throttleOff() {
	if (body[view].type === "Artificial") {
		body[view].throttleSwitch = false;
		throttleShow();
	}
}
function throttleUp() {
	if (body[view].type === "Artificial") {
		if (body[view].throttle < 100) { body[view].throttle += 10; }
		throttleShow();
	}
}
function throttleDown() {
	if (body[view].type === "Artificial") {
		if (body[view].throttle > 0) { body[view].throttle -= 10; }
		throttleShow();
	}
}


// keys that will be used must be declared first
const keyState = {
	KeyE: null,
	KeyS: null,
	KeyD: null,
	KeyF: null,
	KeyW: null,
	KeyR: null,
	KeyQ: null,
	KeyA: null,
	KeyZ: null,
	KeyX: null,
	KeyV: null,
	KeyT: null,
	KeyG: null
}

// initialize last effective date of keypresses for repeat delay
const keyDelay = {
	KeyE: 0,
	KeyS: 0,
	KeyD: 0,
	KeyF: 0,
	KeyW: 0,
	KeyR: 0,
	KeyQ: 0,
	KeyA: 0,
	KeyZ: 0,
	KeyX: 0,
	KeyV: 0,
	KeyT: 0,
	KeyG: 0
}

let repeatDelay = 150;

// process keyboard input. 2nd true means use capture phase, not bubble phase
// it is undocumented why capture phase was chosen, could use code review
window.addEventListener("keydown", function(event) {
	keyState[event.code] = true;
}, true);
window.addEventListener("keyup", function(event) {
	keyState[event.code] = false;
	keyDelay[event.code] = 0;
}, true);

function rocketControl() {
	// e (pitch up)
	if (keyState.KeyE && Date.now() - keyDelay.KeyE > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].xSpin += spinPower;
			keyDelay.KeyE = Date.now();
		}
	}

	// s (yaw left)
	if (keyState.KeyS && Date.now() - keyDelay.KeyS > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].zSpin += spinPower;
			keyDelay.KeyS = Date.now();
		}
	}

	// d (pitch down)
	if (keyState.KeyD && Date.now() - keyDelay.KeyD > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].xSpin -= spinPower;
			keyDelay.KeyD = Date.now();
		}
	}

	// f (yaw right)
	if (keyState.KeyF && Date.now() - keyDelay.KeyF > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].zSpin -= spinPower;
			keyDelay.KeyF = Date.now();
		}
	}

	// w (roll left)
	if (keyState.KeyW && Date.now() - keyDelay.KeyW > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].ySpin -= spinPower;
			keyDelay.KeyW = Date.now();
		}
	}

	// r (roll right)
	if (keyState.KeyR && Date.now() - keyDelay.KeyR > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].ySpin += spinPower;
			keyDelay.KeyR = Date.now();
		}
	}

	// freeze all spin and thrust
	if (keyState.KeyQ && Date.now() - keyDelay.KeyQ > repeatDelay) {
		if (body[view].type === "Artificial") {
			body[view].xSpin = 0;
			body[view].ySpin = 0;
			body[view].zSpin = 0;
			keyDelay.KeyQ = Date.now();
		}
	}

	if (keyState.KeyA && Date.now() - keyDelay.KeyA > repeatDelay) {
		if (body[view].type === "Artificial") {
			throttleUp();
			keyDelay.KeyA = Date.now();
		}
	}
	if (keyState.KeyZ && Date.now() - keyDelay.KeyZ > repeatDelay) {
		if (body[view].type === "Artificial") {
			throttleDown();
			keyDelay.KeyZ = Date.now();
		}
	}
	if (keyState.KeyX && Date.now() - keyDelay.KeyX > repeatDelay) {
		if (body[view].type === "Artificial") {
			throttleOff();
			keyDelay.KeyX = Date.now();
		}
	}

	if (keyState.KeyV && Date.now() - keyDelay.KeyV > repeatDelay) {
		viewNext();
		keyDelay.KeyV = Date.now();
	}

	if (keyState.KeyT && Date.now() - keyDelay.KeyT > repeatDelay) {
		faster();
		keyDelay.KeyT = Date.now();
	}
	if (keyState.KeyG && Date.now() - keyDelay.KeyG > repeatDelay) {
		slower();
		keyDelay.KeyG = Date.now();
	}

	// rotate rocket(s)
	for (let i = body.length - 1; i > -1; i--) {
		if (body[i].type === "Artificial") {
			body[i].mesh.rotateX(body[i].xSpin * timestep);
			body[i].mesh.rotateY(body[i].ySpin * timestep);
			body[i].mesh.rotateZ(body[i].zSpin * timestep);
			
			// use this loop to do all rocket maneuvers, without indenting
		//}
	//}

	// process thrust

	// free fuel if timewarping on last drop
	if (body[i].fuelMass > 0 && body[i].throttleSwitch && body[i].throttle > 0) {
		// update the direction vector of rocket
		body[i].pointingM4.extractRotation(body[i].mesh.matrix);
		// get unit vector of direction
		body[i].pointingV3 =
			body[i].mesh.up.clone().applyMatrix4(body[i].pointingM4);

		let airPressure = 0; // Pascals
		// get current air pressure
		if (body[i].focus === earth) {
			if (body[i].gps.alt < 86000) {
				let airData = earthAirData(body[i].gps.alt);
				airPressure = airData.airPressure;
			}
		}

		// decrease mass by fuel used, and reduce fuel amount
		const fuelMassPerSecond = body[i].fuelMass / body[i].burnTime;
		
		let fuelUse = 1;
		if (body[i].fuelMass - (fuelMassPerSecond * body[i].throttle/100 * timestep)
			< 0) {
			// get ratio
			fuelUse = body[i].fuelMass / (fuelMassPerSecond * body[i].throttle/100
				* timestep);
			body[i].fuelMass = 0;
			body[i].burnTime = 0;
		} else {
			body[i].fuelMass -= fuelMassPerSecond * body[i].throttle/100 * timestep;
			body[i].burnTime -= body[i].throttle/100 * timestep;
		}
		body[i].mass -= fuelMassPerSecond * body[i].throttle/100 * timestep *
			fuelUse;

		const thrustAccel = (body[i].thrustVac - (airPressure *
			(body[i].thrustVac - body[i].thrustSea) / 101325))
			/ body[i].mass * fuelUse;

		// apply thrust according to direction the rocket is pointing
		body[i].vx +=
			body[i].pointingV3.x * body[i].throttle/100 * thrustAccel * timestep;
		body[i].vy +=
			body[i].pointingV3.y * body[i].throttle/100 * thrustAccel * timestep;
		body[i].vz +=
			body[i].pointingV3.z * body[i].throttle/100 * thrustAccel * timestep;

		if (i === view) {
			document.getElementById("hudFuel").innerHTML =
				body[i].fuelMass.toFixed(0) + "<br>kg fuel";
		}

		body[i].onSurface = false;
		
		// missing closes from non-indentation
	}
	}
	
	}
}


////////////////////////////////////////////////////////////////////////////////
// nbody physics
// calculate all nbody forces at a point in time, and update velocities
// Euler-Cromer method AKA Symplectic Euler (almost identical to leapfrog)
/*
	requires:
		body [array]
			x, y, z, vx, vy, vz, mass [meters, m/s, kg]
		GRAVITY [universal constant]
		timestep [seconds]

	returns:
		body [array]
			focusForce, focus, distanceX, distanceY, distanceZ, distance
*/
//let currentFocus = body[8].focus;
//let debugLog = 0;

function nBodyVelocity(/*body, GRAVITY, timestep*/) {
	for (let i = body.length - 1; i > -1; i--) {

		// initialize most influential gravity value
		body[i].focusForce = 0;
		body[i].focusDistance = 1;

		for (let j = body.length - 1; j > -1; j--) {
			if (i === j) continue;

			// compare system positions (not local positions)
			let distanceX = body[j].x - body[i].x;
			let distanceY = body[j].y - body[i].y;
			let distanceZ = body[j].z - body[i].z;
			let distance = Math.sqrt(distanceX**2 + distanceY**2 + distanceZ**2);

			// avoid division by zero
			if (distance === 0) continue;

			// newton's law of universal gravitation, but only in one direction
			let force = GRAVITY * (body[j].mass / distance**2);

			/* dangerous with nbody physics if anything is ejected
			// do NOT dynamically re-assign these objects. just update.
			if (body[i].type === "Natural") {
				if (j === body[i].focus) {
					body[i].focusForce = force;
					body[i].focusDistanceX = distanceX;
					body[i].focusDistanceY = distanceY;
					body[i].focusDistanceZ = distanceZ;
					body[i].focusDistance = distance;
				}
			}
			*/

			// save the most influential object (overwritten until found)
			if (force / distance > body[i].focusForce / body[i].focusDistance &&
				body[j].mass > body[i].mass) {

				body[i].focusForce = force;
				body[i].focus = j;
				body[i].focusDistanceX = distanceX;
				body[i].focusDistanceY = distanceY;
				body[i].focusDistanceZ = distanceZ;
				body[i].focusDistance = distance;
			}

			// update system velocity
			body[i].vx += force * (distanceX / distance) * timestep;
			body[i].vy += force * (distanceY / distance) * timestep;
			body[i].vz += force * (distanceZ / distance) * timestep;
		}
	}

	/*
	// debug stuff
	if (body[8].focus !== currentFocus) {
		debugLog = 0;
		currentFocus = body[8].focus;
	}
	if (debugLog < 3) {
		debugLog++;
		console.log("debugLog: " + debugLog + ", focus: " + body[8].focus,
			body[8].x +", "+ body[8].y +", "+ body[8].z);
	}
	*/
	return body;
}


document.getElementById("eclipticPlane").checked = true;
let reportPlane = "ecliptic";
let keplerAltPlane; // alternative plane, object for reportPlane

function setPlane(value) {
	switch (value) {
		case "ecliptic":
			reportPlane = "ecliptic";
			break;
		case "body":
			reportPlane = "body";
			break;
		case "invariable":
			reportPlane = "invariable";
			break;
		case "galactic":
			reportPlane = "galactic";
			break;
		case "icrf":
			reportPlane = "icrf";
			break;
		default:
			reportPlane = "ecliptic";
	}
}

////////////////////////////////////////////////////////////////////////////////
// keplerian physics
// compute local position, subtract greatest force (use it through
// kepler's 2-body equations). tilt from icrf to "eci" body frame,
// convert to elements, increment time, add j2, convert to vectors using
// kepler's equation, get ecef, and untilt
/*
	depends:
		icrfToEci()
		eciToIcrf()
		toKepler()
		toCartes()
		nodalPrecession()
		eciToEcef()
		...

	requires:
		body [array]
			cartes, focus, distanceXYZ..., focusForce, mass...
		timestep
		mostMassiveBody
		...

	returns:
		cartes [icrf] (computes cartes eci but doesn't save it)
		kepler [eci]
		ecef
		surfacePeriapsis
		...

*/

// calculate keplerian orbit, update local positions
function keplerPosition() {
	// skip sun. order is important. natural body spin before satellites.
	for (let i = 1; i < body.length; i++) {

		// prepare
		const focus = body[i].focus;

		// get new local vectors (icrf)
		body[i].cartes.x = -body[i].focusDistanceX;
		body[i].cartes.y = -body[i].focusDistanceY;
		body[i].cartes.z = -body[i].focusDistanceZ;
		body[i].cartes.vx = body[i].vx - body[focus].vx;
		body[i].cartes.vy = body[i].vy - body[focus].vy;
		body[i].cartes.vz = body[i].vz - body[focus].vz;

////////////////////////////////////////////////////////////////////////////////
// compute new position using kepler's equation (change meanAnom)

		// subtract gravity of parent. the keplerian orbit will add this.
		body[i].cartes.vx -= body[i].focusForce *
			(body[i].focusDistanceX / body[i].focusDistance) * timestep;
		body[i].cartes.vy -= body[i].focusForce *
			(body[i].focusDistanceY / body[i].focusDistance) * timestep;
		body[i].cartes.vz -= body[i].focusForce *
			(body[i].focusDistanceZ / body[i].focusDistance) * timestep;

		// tilt the orbit to match parent body frame (axial tilt)
		body[i].cartesEci = icrfToEci(body[i].cartes, body[focus].rightAscension,
			body[focus].declination);

		/*
		if (i === 8 && debugLog < 3) {
			console.log("1. initial eci vectors",
				body[i].cartesEci.x, body[i].cartesEci.y, body[i].cartesEci.z,
				body[i].cartesEci.vx, body[i].cartesEci.vy, body[i].cartesEci.vz,
				body[i].cartesEci.meanAnom + " meanAnom",
				body[i].cartesEci.eAnom + " eAnom",
				body[i].cartesEci.truAnom + " truAnom",
				body[i].cartesEci.truAnomB + " truAnomB",
				body[i].cartesEci.h + " h");
		}
		*/
		// use the updated vectors and mu to get keplerian elements
		body[i].mu = GRAVITY * (body[focus].mass + body[i].mass);
		body[i].kepler = toKepler(body[i].cartesEci, body[i].mu);
		/*
		if (i === 8 && debugLog < 3) {
			console.log("2. initial elements",
				body[i].kepler.a, body[i].kepler.e, body[i].kepler.i,
				body[i].kepler.lan, body[i].kepler.w,
				body[i].kepler.meanAnom + " meanAnom",
				body[i].kepler.eAnom + " eAnom",
				body[i].kepler.truAnom + " truAnom",
				body[i].kepler.vRadial + " vRadial",
				body[i].kepler.truAnomTest + " truAnomTest");
		}
		*/

		if (!body[i].onSurface) {
			// increment position (this code IS compatible with hyperbolic)
			// add to mean anomaly (rene schwarz method). units in seconds
			body[i].kepler.meanAnom += timestep *
				Math.sqrt(body[i].mu / Math.abs(body[i].kepler.a)**3);
			//body[i].kepler.eAnom = null;
			//body[i].kepler.truAnom = null;

			// keep meanAnom within range BUT ONLY FOR ELLIPSES (CLOSED ORBITS)
			if (body[i].kepler.e < 1) {
				body[i].kepler.meanAnom %= 2 * Math.PI;
			}

			// add J2 zonal harmonic nodal precession (oblate spheroid gravity)
			if (body[i].kepler.periapsis - body[focus].radiusPole > 0
				//&& body[i].kepler.e < 1
				) {
				body[i].nodal = nodalPrecession(body[i].kepler, body[i].mu,
					body[focus].J2, body[focus].radiusEquator);
				body[i].kepler.lan += body[i].nodal.lanRate * timestep;
				body[i].kepler.w += body[i].nodal.wRate * timestep;
			}
		}

		/*
		if (i === 8 && debugLog < 3) {
			console.log("post-move elements",
				body[i].kepler.a, body[i].kepler.e, body[i].kepler.i,
				body[i].kepler.lan, body[i].kepler.w, body[i].kepler.meanAnom);
		}
		*/

		// use the new keplerian elements to get new vectors
		body[i].cartesEci = toCartes(body[i].kepler, body[i].mu);


		/*
		if (i === 8 && debugLog < 3) {
			console.log("3. post-move vectors",
				body[i].cartesEci.x, body[i].cartesEci.y, body[i].cartesEci.z,
				body[i].cartesEci.vx, body[i].cartesEci.vy, body[i].cartesEci.vz,
				body[i].cartesEci.meanAnom + " meanAnom",
				body[i].cartesEci.eAnom + " eAnom",
				body[i].cartesEci.truAnom + " truAnom",
				body[i].cartesEci.truAnomB + " truAnomB",
				body[i].cartesEci.h + " h");
		}
		*/

////////////////////////////////////////////////////////////////////////////////
// symplectic euler method

/*
//function nBodyPosition() {
	//for (let i = body.length -1; i > -1; i--) {
		body[i].cartes.x += body[i].cartes.vx * timestep;
		body[i].cartes.y += body[i].cartes.vy * timestep;
		body[i].cartes.z += body[i].cartes.vz * timestep;

		body[i].cartesEci = icrfToEci(body[i].cartes, body[focus].rightAscension,
			body[focus].declination);

		// get new kepler from cartes
		body[i].mu = GRAVITY * (body[focus].mass + body[i].mass);
		body[i].kepler = toKepler(body[i].cartesEci, body[i].mu);
//	}
//}
*/

////////////////////////////////////////////////////////////////////////////////

		/*
		if (body[i].cartesEci.iterations === body[i].cartesEci.maxIterations) {
			console.log(body[i].name + " is being ejected.");
			body.splice(i);
			continue;
			// what if it is a focus when ejected? potential bug
		}
		*/

		/*
		{
			let {x, y, z, vx, vy, vz} = body[i].cartesEci;

			if (isNaN(x) || isNaN(y) || isNaN(z) ||
				isNaN(vx) || isNaN(vy) || isNaN(vz)) {

				console.log("ERROR. index: " + i + ", name: " + body[i].name);
				//console.log(ct);
				//console.log(kt);
				console.log("onSurface: " + body[i].onSurface);
				//console.log(m1, m2);
				console.log(body[i].kepler);
				console.log(body[i].cartesEci);
				console.log(x, y, z, vx, vy, vz);

				clearInterval(loop);
				return;
				//playPause();
				//debugger;
				//throw new Error("just stop...");
				//failerFunction();
				//new new;
			}
		}
		*/

		// celestial body rotations
		if (body[i].type === "Natural") {
			if (body[i].tidallyLocked !== true) {
				body[i].mesh.rotateY(body[i].angularVelocity * timestep);
				body[i].spun += body[i].angularVelocity * timestep;
			} else {
				// cartes.truAnom is new, kepler.truAnom is old
				body[i].mesh.rotateY(body[i].cartesEci.truAnom -
					body[i].kepler.truAnom);
				body[i].spun += body[i].cartesEci.truAnom - body[i].kepler.truAnom;
			}
			body[i].spun %= 2 * Math.PI;
		} else {
		//if (body[i].type === "Artificial") {

		// get Earth-Centered-Earth-Fixed and GPS coordinates
			if (!body[i].onSurface) {
				body[i].ecef = eciToEcef(body[i].cartesEci,
					body[focus].spun,
					body[focus].angularVelocity,
					body[focus].radiusEquator, body[focus].e2);
				body[i].gps = ecefToGps(body[i].ecef, body[focus].radiusEquator,
					body[focus].e2);
				if (body[i].gps.alt < 0) {
					// pop back up to surface (this has issues)
					//body[i].gps.alt = 0;

					// obstruction of ground eliminates velocity
					body[i].ecef.vx = 0;
					body[i].ecef.vy = 0;
					body[i].ecef.vz = 0;
					body[i].onSurface = true;
				}
			}

			if (body[i].onSurface) {
				// use ecef to move with surface
				body[i].cartesEci = ecefToEci(body[i].ecef,
					body[focus].spun,
					body[focus].angularVelocity, body[focus].radiusEquator,
					body[focus].e2);
			} else if (body[i].focus === earth) {

				// drag goes here


				// process drag

					// get prograde vector from velocity
					body[i].ecef.prograde = new THREE.Vector3(
						body[i].ecef.vx,
						body[i].ecef.vy,
						body[i].ecef.vz);
					body[i].ecef.prograde.normalize();

					//let airData = earthAirData(body[i].gps.alt);
					let velocity = Math.sqrt(
						body[i].ecef.vx**2 +
						body[i].ecef.vy**2 +
						body[i].ecef.vz**2);

					let density = 1.225; // earth MSL air density
					if (body[i].gps.alt < 86000) {
						let airData = earthAirData(body[i].gps.alt);
						density = airData.airDensity;
					} else {
						density = earthAtmosphere(body[i].gps.alt);
					}

					let dragCoefficient = 0.5; // spherical drag
					//let dragCoefficient = 0.75; // sphere
					if (body[i].gps.alt > 100000) {
						dragCoefficient = 2.2; // cubesat
						//dragCoefficient = 0.75; // sphere (for sputnik 1)
						//body[i].mass = 138054; // falcon 9 without fuel in stage 1

						// DISABLE DUE TO NEW THRUST CODE
						//body[i].mass = 83.6; // sputnik 1
					}

					body[i].drag = dragEquation(density, velocity, body[i].mass,
						dragCoefficient);

					// prepare for safety checks (could be optimized)
					let vxSign = Math.sign(body[i].ecef.vx);
					let vySign = Math.sign(body[i].ecef.vy);
					let vzSign = Math.sign(body[i].ecef.vz);
					let vxDrag = 
						-body[i].ecef.prograde.x * body[i].drag * timestep;
					let vyDrag = 
						-body[i].ecef.prograde.y * body[i].drag * timestep;
					let vzDrag = 
						-body[i].ecef.prograde.z * body[i].drag * timestep;

					// if adding drag results in the same direction, apply it
					if (Math.sign(body[i].ecef.vx + vxDrag) === vxSign) {
						// apply drag. negative prograde is retrograde.
						body[i].ecef.vx +=
							-body[i].ecef.prograde.x * body[i].drag * timestep;
						// if it results in going backwards (an issue with timestepping
						// and/or super fast drag calculated on a 0 or negative altitude),
						// then just zero the velocity instead
					} else {
						body[i].ecef.vx = 0;
					}

					// repeat for y and z
					if (Math.sign(body[i].ecef.vy + vyDrag) === vySign) {
						body[i].ecef.vy +=
							-body[i].ecef.prograde.y * body[i].drag * timestep;
					} else {
						body[i].ecef.vy = 0;
					}
					if (Math.sign(body[i].ecef.vz + vzDrag) === vzSign) {
						body[i].ecef.vz +=
							-body[i].ecef.prograde.z * body[i].drag * timestep;
					} else {
						body[i].ecef.vz = 0;
					}
					// independent safety checks on all 3 vectors, instead of checking
					// final prograde direction, may have an issue, or may be better

					// send info back up the chain
					body[i].cartesEci = ecefToEci(body[i].ecef,
					body[focus].spun,
					body[focus].angularVelocity, body[focus].radiusEquator,
					body[focus].e2);
				}
			}
		// tilt back, to match icrf frame
		body[i].cartes = eciToIcrf(body[i].cartesEci,
			body[focus].rightAscension, body[focus].declination);
	} // close for loop
}




////////////////////////////////////////////////////////////////////////////////
// path drawing functions

// draw: body index requiring .kepler elements (i.e. body[i].kepler)
// shade: color in hex format (i.e. 0xff0000 for red), only used on first run
// scale: meters to render scale
function drawEllipse(draw, shade, scale) {

	// just get i, lan, and w from icrf. a and e are the same as eci.
	let kepi = toKepi(body[draw].cartes, body[draw].mu);

	// use absolute for safety in case of hyperbola
	const a = Math.abs(body[draw].kepler.a) * scale;
	const e = body[draw].kepler.e;
	const i = kepi.i;
	const lan = kepi.lan;
	const w = kepi.w;

	const b = a * Math.sqrt(1 - e**2);
	const c = -Math.sqrt(a**2 - b**2);

	const curve = new THREE.EllipseCurve(
		c, 0,                  // aX, aY (center of rotation)
		a, b,                  // xRadius, yRadius
		0, 2 * Math.PI,        // aStartAngle, aEndAngle
		false,                 // aClockwise
		0                      // aRotation
	);

	const points = curve.getPoints(500);

	if (body[draw].ellipse === undefined) {

		const geometry = new THREE.BufferGeometry().setFromPoints(points);
		const material = new THREE.LineBasicMaterial({ color: shade });
		body[draw].ellipse = new THREE.Line(geometry, material);

		// prevent clipping
		body[draw].ellipse.frustumCulled = false;

		scene.add(body[draw].ellipse);

	}

	body[draw].ellipse.geometry.dispose();
	body[draw].ellipse.geometry = new
		THREE.BufferGeometry().setFromPoints(points);

	body[draw].ellipse.rotation.set(0, 0, 0);

	body[draw].ellipse.rotation.x -= Math.PI / 2;
	body[draw].ellipse.rotation.y -= lan;
	body[draw].ellipse.rotateX(i);
	body[draw].ellipse.rotateY(-w);
	body[draw].ellipse.rotateX(Math.PI / 2);

	const focus = body[draw].focus;

	body[draw].ellipse.position.copy(body[focus].mesh.position);

}


////////////////////////////////////////////////////////////////////////////////
// display data on-screen


function displayText() {
	let vFocus = body[view].focus;

	if (view === mostMassiveBody) {
		document.getElementById("hudDateOrbit").innerHTML = now.toISOString() +
			"<br>r " +
			(Math.sqrt(body[view].x**2 + body[view].y**2 + body[view].z**2) / 1000).
			toFixed(3) + " km" +
			"<br>x " + (body[view].x / 1000).toFixed(3) + " km" +
			"<br>y " + (body[view].y / 1000).toFixed(3) + " km" +
			"<br>z " + (body[view].z / 1000).toFixed(3) + " km" +
			"<br>vx " + (body[view].vx / 1000).toFixed(3) + " km/s" +
			"<br>vy " + (body[view].vy / 1000).toFixed(3) + " km/s" +
			"<br>vz " + (body[view].vz / 1000).toFixed(3) + " km/s" +
			"<br>v " +
			(Math.sqrt(body[view].vx**2 + body[view].vy**2 + body[view].vz**2) /
			1000).toFixed(3) + " km/s";
	} else {
		let keplerShow;
		if (body[view].focus === 0 && reportPlane !== "body") {
			// get elements in ecliptic etc frame, just for reporting data to user
			if (reportPlane === "ecliptic") {
				const cartesAltPlane = icrfToEci(body[view].cartes,
				// RA 270 * Math.PI / 180 = 4.71238898038469
					4.71238898038469,
				// DEC 90 - 23.43929 = 66.56071, * Math.PI / 180 = 1.161703541965115
					1.161703541965115);
				keplerShow = toKepler(cartesAltPlane, body[view].mu);
			} else if (reportPlane === "icrf") {
				// currently in icrf frame
				keplerShow = toKepler(body[view].cartes, body[view].mu);
			} else if (reportPlane === "galactic") {
				const cartesAltPlane = icrfToEci(body[view].cartes,
					0.38147085502186906, // 21.85667 deg
					0.4735078260660616); // 27.13 deg
				keplerShow = toKepler(cartesAltPlane, body[view].mu);
			} else { // invariable
				const cartesAltPlane = icrfToEci(body[view].cartes,
					4.779584156586472, // 273.85 deg
					1.1691960659110012); // 66.99 deg
				keplerShow = toKepler(cartesAltPlane, body[view].mu);
			}
		} else {
			keplerShow = body[view].kepler;
		}
		document.getElementById("hudDateOrbit").innerHTML = now.toISOString() +
			"<br>period " + secondsToYears(
				2*Math.PI / Math.sqrt(body[view].mu) * keplerShow.a**(3/2)) +
			"<br>a " + (keplerShow.a / 1000).toFixed(3) + " km" +
			"<br>e " + (keplerShow.e).toFixed(9) +
			"<br>i " + (keplerShow.i * 180 / Math.PI).toFixed(7) + "°" +
			"<br>Ω " + (keplerShow.lan * 180 / Math.PI).toFixed(5) + "°" +
			"<br>ω " + (keplerShow.w * 180 / Math.PI).toFixed(7) + "°" +
			"<br>M " + (keplerShow.meanAnom * 180 / Math.PI).toFixed(5) + "°" +
			"<br>v<sub>o</sub> " + (keplerShow.v / 1000).toFixed(3) + " km/s" +
			"<br>Apo  " + (keplerShow.apoapsis / 1000).toFixed(3) + " km" +
			"<br>Peri " + (keplerShow.periapsis / 1000).toFixed(3) + " km";
	}

	if (body[view].type === "Artificial") {
		document.getElementById("hudGpsInfo").innerHTML =
			"Alt " + (body[view].gps.alt / 1000).toFixed(6) + " km" +
			"<br>v<sub>s</sub> " + (Math.sqrt(body[view].ecef.vx**2 +
				body[view].ecef.vy**2 +
				body[view].ecef.vz**2) / 1000).toFixed(6) + " km/s" +
			"<br>drag " + body[view].drag.toExponential(2) + " m/s²" +
			"<br>Mass " + body[view].mass.toExponential(3) + " kg" +
			"<br>Lat " + (body[view].gps.lat * 180 / Math.PI).toFixed(6) + "°" +
			"<br>Lon " + (body[view].gps.lon * 180 / Math.PI).toFixed(6) + "°" +
			"<br>Apo<sub>s</sub>  " + ((body[view].kepler.apoapsis -
				body[vFocus].radiusEquator)
				/ 1000).toFixed(3) + " km" +
			"<br>Peri<sub>s</sub> " + ((body[view].kepler.periapsis -
				body[vFocus].radiusEquator) / 1000).toFixed(3) + " km";

	} else {
		document.getElementById("hudGpsInfo").innerHTML =
			"Mass " + body[view].mass.toExponential(3) + " kg" +
			"<br>EqRad " + (body[view].radiusEquator / 1000).toFixed(0) + " km" +
			"<br>PoRad " + (body[view].radiusPole / 1000).toFixed(0) + " km" +
			"<br>Sidereel " + body[view].sidereal.toFixed(2) + " hr";
	}

	// update in case object is now orbiting something else
	if (view !== 0) {
		document.getElementById("hudView").innerHTML = body[view].name + "<br>@ " +
			body[body[view].focus].name;
	} else {
		document.getElementById("hudView").innerHTML = body[view].name + "<br>@ " +
			"mlky";
	}
}


////////////////////////////////////////////////////////////////////////////////
// main loop

// main loop (separate from animation loop)
function main() {

	// spin and throttle rocket
	rocketControl();

	// calculate new velocities for everything (true n-body physics.
	//body = nBodyVelocity(body, GRAVITY, timestep);
	nBodyVelocity();

	// update sun position. relative to system barycenter. no keplerian orbit
	body[mostMassiveBody].x += body[mostMassiveBody].vx * timestep;
	body[mostMassiveBody].y += body[mostMassiveBody].vy * timestep;
	body[mostMassiveBody].z += body[mostMassiveBody].vz * timestep;
	body[mostMassiveBody].mesh.rotateY(
		body[mostMassiveBody].angularVelocity * timestep);
	body[mostMassiveBody].spun +=
		body[mostMassiveBody].angularVelocity * timestep;

	// update everything else's position within the context of a 2-body problem
	keplerPosition();

	// update sun mesh position. relative to system barycenter
	body[mostMassiveBody].mesh.position.x = body[mostMassiveBody].x * scale;
	body[mostMassiveBody].mesh.position.y = body[mostMassiveBody].y * scale;
	body[mostMassiveBody].mesh.position.z = body[mostMassiveBody].z * scale;


	while (bodyQueue.length > 0) {
		let i = body.push(bodyQueue.pop()) - 1;
		addRocket(i);
		
	}


	// get everything else's solar system position based on local position
	systemPosition();

	// increment time
	now.setMilliseconds(now.getMilliseconds() + timestep * 1000);

	displayText();

	preAnimate();
}



document.querySelector("#allOrbits").checked = false;
let drawOrbits = false;
function toggleAllOrbits() {
	if (drawOrbits) {
		if (drawLocalOrbits) {
			// skip sun
			for (let i = body.length - 1; i > 0; i--) {
				if (body[i].focus !== body[rocket].focus) {
					body[i].ellipse.visible = false;
				}
			}
		} else {
			// skip sun
			for (let i = body.length - 1; i > 0; i--) {
				body[i].ellipse.visible = false;
			}
		}
	}
	drawOrbits = !drawOrbits;
}

document.querySelector("#localOrbits").checked = false;
let drawLocalOrbits = false;
function toggleLocalOrbits() {
	drawLocalOrbits = !drawLocalOrbits;
	if (!drawOrbits) {
		for (let i = body.length - 1; i > 0; i--) {
			if (body[i].ellipse) {
				body[i].ellipse.visible = false;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
// preAnimate


//let skipDraw = 0;
let navQ = new THREE.Quaternion();
let oldViewX = 0;
let oldViewY = 0;
let oldViewZ = 0;
function preAnimate() {

	if (drawOrbits === true) {
		// skip the sun because it doesn't have orbital parameters
		for (let i = body.length - 1; i > 0; i--) {

			//if (body[i].type === "Artificial") {
			drawEllipse(i, body[i].color, scale);
			body[i].ellipse.visible = true;
/*
			} else {
				if (skipDraw === 0) {
					drawEllipse(i, body[i].color, scale);
					skipDraw = 1000;
				} else {
					skipDraw--;
				}
			}
*/
		}
	} else if (drawLocalOrbits === true) {
		for (let i = body.length - 1; i > 0; i--) {
			if (body[i].focus === body[rocket].focus) {
				drawEllipse(i, body[i].color, scale);
				body[i].ellipse.visible = true;
			} else {
				if (body[i].ellipse) {
					body[i].ellipse.visible = false;
				}
			}
		}
	}

////////////////////////////////////////////////////////////////////////////////
// NAVBALL

	if (body[view].type === "Artificial") {
		let focus = body[view].focus;
		let enu = getDirections(body[view].cartes.x, body[view].cartes.y,
			body[view].cartes.z, body[focus].mesh.quaternion);

		let navM4 = new THREE.Matrix4().makeBasis(
			enu.northAxisV3, enu.upAxisV3, enu.eastAxisV3);

		navQ.setFromRotationMatrix(navM4);

		navBall.quaternion.copy(
			// functional orientation before applying navQ (rotations in world space)
			new THREE.Quaternion().setFromAxisAngle(zAxis, Math.PI)
			.multiply(new THREE.Quaternion().setFromAxisAngle(xAxis, -Math.PI / 2))

			// apply nav
			.multiply(navQ)

			// texture orientation after applying nav (rotations in local/object space)
			.multiply(new THREE.Quaternion().setFromAxisAngle(xAxis, Math.PI))
			.multiply(new THREE.Quaternion().setFromAxisAngle(yAxis, Math.PI))
		);

		// apply spacecraft rotation relative to stars
		// swap y and z. must implement in original order.
		navBall.rotateOnWorldAxis(xAxis, body[view].mesh.rotation.x);
		navBall.rotateOnWorldAxis(zAxis, body[view].mesh.rotation.y);
		navBall.rotateOnWorldAxis(yAxis, body[view].mesh.rotation.z);
	}

////////////////////////////////////////////////////////////////////////////////
// HELPERS


	// icrf
	for (let i = body.length - 1; i > -1; i--) {
		if (body[i].axesHelperIcrf) {
			body[i].axesHelperIcrf.position.copy(body[i].mesh.position);
		}
	}




////////////////////////////////////////////////////////////////////////////////
// finish animation

	// attach/add camera as child to object doesn't work so well
	// keep the camera relative to its target
	camera.position.x += body[view].mesh.position.x - oldViewX;
	camera.position.y += body[view].mesh.position.y - oldViewY;
	camera.position.z += body[view].mesh.position.z - oldViewZ;
	oldViewX = body[view].mesh.position.x;
	oldViewY = body[view].mesh.position.y;
	oldViewZ = body[view].mesh.position.z;
}

function animate() {
	requestAnimationFrame(animate);

	controls.update();

	renderer.clear();
	renderer.render(scene, camera);
	renderer.clearDepth();
	renderer.render(scene2, camera2);
}
animate();


let loop = setInterval(main, 10);
let running = true;
function playPause() {
	if (running === true) {
		clearInterval(loop);
		running = false;
	}
	else {
		loop = setInterval(main, 10);
		running = true;
	}
}
		</script>
	</body>
</html>
